diff -uNr llvm-toolchain-14-14.0.6.orig/clang/CMakeLists.txt.orig llvm-toolchain-14-14.0.6/clang/CMakeLists.txt.orig
--- llvm-toolchain-14-14.0.6.orig/clang/CMakeLists.txt.orig	2021-09-20 17:59:03.000000000 +0800
+++ llvm-toolchain-14-14.0.6/clang/CMakeLists.txt.orig	1970-01-01 08:00:00.000000000 +0800
@@ -1,904 +0,0 @@
-cmake_minimum_required(VERSION 3.13.4)
-
-# If we are not building as a part of LLVM, build Clang as an
-# standalone project, using LLVM as an external library:
-if( CMAKE_SOURCE_DIR STREQUAL CMAKE_CURRENT_SOURCE_DIR )
-  project(Clang)
-
-  set(CMAKE_CXX_STANDARD 14 CACHE STRING "C++ standard to conform to")
-  set(CMAKE_CXX_STANDARD_REQUIRED YES)
-  set(CMAKE_CXX_EXTENSIONS NO)
-
-  # Rely on llvm-config.
-  set(CONFIG_OUTPUT)
-  if(LLVM_CONFIG)
-    set (LLVM_CONFIG_FOUND 1)
-    message(STATUS "Found LLVM_CONFIG as ${LLVM_CONFIG}")
-    message(DEPRECATION "Using llvm-config to detect the LLVM installation is \
-          deprecated.  The installed cmake files should be used \
-          instead.  CMake should be able to detect your LLVM install \
-          automatically, but you can also use LLVM_DIR to specify \
-          the path containing LLVMConfig.cmake.")
-    set(CONFIG_COMMAND ${LLVM_CONFIG}
-      "--assertion-mode"
-      "--bindir"
-      "--libdir"
-      "--includedir"
-      "--prefix"
-      "--src-root"
-      "--cmakedir")
-    execute_process(
-      COMMAND ${CONFIG_COMMAND}
-      RESULT_VARIABLE HAD_ERROR
-      OUTPUT_VARIABLE CONFIG_OUTPUT
-    )
-    if(NOT HAD_ERROR)
-      string(REGEX REPLACE
-        "[ \t]*[\r\n]+[ \t]*" ";"
-        CONFIG_OUTPUT ${CONFIG_OUTPUT})
-    else()
-      string(REPLACE ";" " " CONFIG_COMMAND_STR "${CONFIG_COMMAND}")
-      message(STATUS "${CONFIG_COMMAND_STR}")
-      message(FATAL_ERROR "llvm-config failed with status ${HAD_ERROR}")
-    endif()
-
-    list(GET CONFIG_OUTPUT 0 ENABLE_ASSERTIONS)
-    list(GET CONFIG_OUTPUT 1 TOOLS_BINARY_DIR)
-    list(GET CONFIG_OUTPUT 2 LIBRARY_DIR)
-    list(GET CONFIG_OUTPUT 3 INCLUDE_DIR)
-    list(GET CONFIG_OUTPUT 4 LLVM_OBJ_ROOT)
-    list(GET CONFIG_OUTPUT 5 MAIN_SRC_DIR)
-    list(GET CONFIG_OUTPUT 6 LLVM_CONFIG_CMAKE_DIR)
-
-    # Normalize LLVM_CMAKE_DIR. --cmakedir might contain backslashes.
-    # CMake assumes slashes as PATH.
-    file(TO_CMAKE_PATH ${LLVM_CONFIG_CMAKE_DIR} LLVM_CMAKE_DIR)
-  endif()
-
-
-  if(NOT MSVC_IDE)
-    set(LLVM_ENABLE_ASSERTIONS ${ENABLE_ASSERTIONS}
-      CACHE BOOL "Enable assertions")
-    # Assertions should follow llvm-config's.
-    mark_as_advanced(LLVM_ENABLE_ASSERTIONS)
-  endif()
-
-  find_package(LLVM REQUIRED HINTS "${LLVM_CMAKE_DIR}")
-  list(APPEND CMAKE_MODULE_PATH ${LLVM_DIR})
-
-  # We can't check LLVM_CONFIG here, because find_package(LLVM ...) also sets
-  # LLVM_CONFIG.
-  if (NOT LLVM_CONFIG_FOUND)
-    # Pull values from LLVMConfig.cmake.  We can drop this once the llvm-config
-    # path is removed.
-    set(TOOLS_BINARY_DIR ${LLVM_TOOLS_BINARY_DIR})
-    set(LIBRARY_DIR ${LLVM_LIBRARY_DIR})
-    set(INCLUDE_DIR ${LLVM_INCLUDE_DIR})
-    set(LLVM_OBJ_DIR ${LLVM_BINARY_DIR})
-  endif()
-
-  set(LLVM_TOOLS_BINARY_DIR ${TOOLS_BINARY_DIR} CACHE PATH "Path to llvm/bin")
-  set(LLVM_LIBRARY_DIR ${LIBRARY_DIR} CACHE PATH "Path to llvm/lib")
-  set(LLVM_MAIN_INCLUDE_DIR ${INCLUDE_DIR} CACHE PATH "Path to llvm/include")
-  set(LLVM_BINARY_DIR ${LLVM_OBJ_ROOT} CACHE PATH "Path to LLVM build tree")
-  set(LLVM_MAIN_SRC_DIR ${MAIN_SRC_DIR} CACHE PATH "Path to LLVM source tree")
-
-  find_program(LLVM_TABLEGEN_EXE "llvm-tblgen" ${LLVM_TOOLS_BINARY_DIR}
-    NO_DEFAULT_PATH)
-
-  # They are used as destination of target generators.
-  set(LLVM_RUNTIME_OUTPUT_INTDIR ${CMAKE_BINARY_DIR}/${CMAKE_CFG_INTDIR}/bin)
-  set(LLVM_LIBRARY_OUTPUT_INTDIR ${CMAKE_BINARY_DIR}/${CMAKE_CFG_INTDIR}/lib${LLVM_LIBDIR_SUFFIX})
-  if(WIN32 OR CYGWIN)
-    # DLL platform -- put DLLs into bin.
-    set(LLVM_SHLIB_OUTPUT_INTDIR ${LLVM_RUNTIME_OUTPUT_INTDIR})
-  else()
-    set(LLVM_SHLIB_OUTPUT_INTDIR ${LLVM_LIBRARY_OUTPUT_INTDIR})
-  endif()
-
-  option(LLVM_INSTALL_TOOLCHAIN_ONLY
-    "Only include toolchain files in the 'install' target." OFF)
-
-  option(LLVM_FORCE_USE_OLD_HOST_TOOLCHAIN
-    "Set to ON to force using an old, unsupported host toolchain." OFF)
-  option(CLANG_ENABLE_BOOTSTRAP "Generate the clang bootstrap target" OFF)
-  option(LLVM_ENABLE_LIBXML2 "Use libxml2 if available." ON)
-
-  include(AddLLVM)
-  include(TableGen)
-  include(HandleLLVMOptions)
-  include(VersionFromVCS)
-  include(GetErrcMessages)
-  include(LLVMDistributionSupport)
-
-  set(PACKAGE_VERSION "${LLVM_PACKAGE_VERSION}")
-  set(BUG_REPORT_URL "${LLVM_PACKAGE_BUGREPORT}" CACHE STRING
-    "Default URL where bug reports are to be submitted.")
-
-  if (NOT DEFINED LLVM_INCLUDE_TESTS)
-    set(LLVM_INCLUDE_TESTS ON)
-  endif()
-
-  include_directories("${LLVM_BINARY_DIR}/include" "${LLVM_MAIN_INCLUDE_DIR}")
-  link_directories("${LLVM_LIBRARY_DIR}")
-
-  set( CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin )
-  set( CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib${LLVM_LIBDIR_SUFFIX} )
-  set( CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib${LLVM_LIBDIR_SUFFIX} )
-
-  if(LLVM_INCLUDE_TESTS)
-    find_package(Python3 ${LLVM_MINIMUM_PYTHON_VERSION} REQUIRED
-      COMPONENTS Interpreter)
-
-    # Check prebuilt llvm/utils.
-    if(EXISTS ${LLVM_TOOLS_BINARY_DIR}/FileCheck${CMAKE_EXECUTABLE_SUFFIX}
-        AND EXISTS ${LLVM_TOOLS_BINARY_DIR}/count${CMAKE_EXECUTABLE_SUFFIX}
-        AND EXISTS ${LLVM_TOOLS_BINARY_DIR}/not${CMAKE_EXECUTABLE_SUFFIX})
-      set(LLVM_UTILS_PROVIDED ON)
-    endif()
-
-    if(EXISTS ${LLVM_MAIN_SRC_DIR}/utils/lit/lit.py)
-      # Note: path not really used, except for checking if lit was found
-      set(LLVM_LIT ${LLVM_MAIN_SRC_DIR}/utils/lit/lit.py)
-      if(EXISTS ${LLVM_MAIN_SRC_DIR}/utils/llvm-lit)
-        add_subdirectory(${LLVM_MAIN_SRC_DIR}/utils/llvm-lit utils/llvm-lit)
-      endif()
-      if(NOT LLVM_UTILS_PROVIDED)
-        add_subdirectory(${LLVM_MAIN_SRC_DIR}/utils/FileCheck utils/FileCheck)
-        add_subdirectory(${LLVM_MAIN_SRC_DIR}/utils/count utils/count)
-        add_subdirectory(${LLVM_MAIN_SRC_DIR}/utils/not utils/not)
-        set(LLVM_UTILS_PROVIDED ON)
-        set(CLANG_TEST_DEPS FileCheck count not)
-      endif()
-      set(UNITTEST_DIR ${LLVM_MAIN_SRC_DIR}/utils/unittest)
-      if(EXISTS ${UNITTEST_DIR}/googletest/include/gtest/gtest.h
-          AND NOT EXISTS ${LLVM_LIBRARY_DIR}/${CMAKE_STATIC_LIBRARY_PREFIX}gtest${CMAKE_STATIC_LIBRARY_SUFFIX}
-          AND EXISTS ${UNITTEST_DIR}/CMakeLists.txt)
-        add_subdirectory(${UNITTEST_DIR} utils/unittest)
-      endif()
-    else()
-      # Seek installed Lit.
-      find_program(LLVM_LIT
-                   NAMES llvm-lit lit.py lit
-                   PATHS "${LLVM_MAIN_SRC_DIR}/utils/lit"
-                   DOC "Path to lit.py")
-    endif()
-
-    if(LLVM_LIT)
-      # Define the default arguments to use with 'lit', and an option for the user
-      # to override.
-      set(LIT_ARGS_DEFAULT "-sv")
-      if (MSVC OR XCODE)
-        set(LIT_ARGS_DEFAULT "${LIT_ARGS_DEFAULT} --no-progress-bar")
-      endif()
-      set(LLVM_LIT_ARGS "${LIT_ARGS_DEFAULT}" CACHE STRING "Default options for lit")
-
-      get_errc_messages(LLVM_LIT_ERRC_MESSAGES)
-
-      # On Win32 hosts, provide an option to specify the path to the GnuWin32 tools.
-      if( WIN32 AND NOT CYGWIN )
-        set(LLVM_LIT_TOOLS_DIR "" CACHE PATH "Path to GnuWin32 tools")
-      endif()
-    else()
-      set(LLVM_INCLUDE_TESTS OFF)
-    endif()
-  endif()
-
-  set( CLANG_BUILT_STANDALONE 1 )
-  set(BACKEND_PACKAGE_STRING "LLVM ${LLVM_PACKAGE_VERSION}")
-else()
-  set(BACKEND_PACKAGE_STRING "${PACKAGE_STRING}")
-endif()
-
-# Make sure that our source directory is on the current cmake module path so that
-# we can include cmake files from this directory.
-list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake/modules")
-
-if(LLVM_ENABLE_LIBXML2)
-  # Don't look for libxml if we're using MSan, since uninstrumented third party
-  # code may call MSan interceptors like strlen, leading to false positives.
-  if(NOT LLVM_USE_SANITIZER MATCHES "Memory.*")
-    set (LIBXML2_FOUND 0)
-    find_package(LibXml2 2.5.3 QUIET)
-    if (LIBXML2_FOUND)
-      set(CLANG_HAVE_LIBXML 1)
-    endif()
-  endif()
-endif()
-
-include(CheckIncludeFile)
-check_include_file(sys/resource.h CLANG_HAVE_RLIMITS)
-
-set(CLANG_RESOURCE_DIR "" CACHE STRING
-  "Relative directory from the Clang binary to its resource files.")
-
-set(C_INCLUDE_DIRS "" CACHE STRING
-  "Colon separated list of directories clang will search for headers.")
-
-set(GCC_INSTALL_PREFIX "" CACHE PATH "Directory where gcc is installed." )
-set(DEFAULT_SYSROOT "" CACHE STRING
-  "Default <path> to all compiler invocations for --sysroot=<path>." )
-
-set(ENABLE_LINKER_BUILD_ID OFF CACHE BOOL "pass --build-id to ld")
-
-set(ENABLE_X86_RELAX_RELOCATIONS ON CACHE BOOL
-    "enable x86 relax relocations by default")
-
-set(CLANG_SPAWN_CC1 OFF CACHE BOOL
-    "Whether clang should use a new process for the CC1 invocation")
-
-# TODO: verify the values against LangStandards.def?
-set(CLANG_DEFAULT_STD_C "" CACHE STRING
-  "Default standard to use for C/ObjC code (IDENT from LangStandards.def, empty for platform default)")
-set(CLANG_DEFAULT_STD_CXX "" CACHE STRING
-  "Default standard to use for C++/ObjC++ code (IDENT from LangStandards.def, empty for platform default)")
-
-set(CLANG_DEFAULT_LINKER "" CACHE STRING
-  "Default linker to use (linker name or absolute path, empty for platform default)")
-
-set(CLANG_DEFAULT_CXX_STDLIB "" CACHE STRING
-  "Default C++ stdlib to use (\"libstdc++\" or \"libc++\", empty for platform default")
-if (NOT(CLANG_DEFAULT_CXX_STDLIB STREQUAL "" OR
-        CLANG_DEFAULT_CXX_STDLIB STREQUAL "libstdc++" OR
-        CLANG_DEFAULT_CXX_STDLIB STREQUAL "libc++"))
-  message(WARNING "Resetting default C++ stdlib to use platform default")
-  set(CLANG_DEFAULT_CXX_STDLIB "" CACHE STRING
-    "Default C++ stdlib to use (\"libstdc++\" or \"libc++\", empty for platform default" FORCE)
-endif()
-
-set(CLANG_DEFAULT_RTLIB "" CACHE STRING
-  "Default runtime library to use (\"libgcc\" or \"compiler-rt\", empty for platform default)")
-if (NOT(CLANG_DEFAULT_RTLIB STREQUAL "" OR
-        CLANG_DEFAULT_RTLIB STREQUAL "libgcc" OR
-        CLANG_DEFAULT_RTLIB STREQUAL "compiler-rt"))
-  message(WARNING "Resetting default rtlib to use platform default")
-  set(CLANG_DEFAULT_RTLIB "" CACHE STRING
-    "Default runtime library to use (\"libgcc\" or \"compiler-rt\", empty for platform default)" FORCE)
-endif()
-
-set(CLANG_DEFAULT_UNWINDLIB "" CACHE STRING
-  "Default unwind library to use (\"none\" \"libgcc\" or \"libunwind\", empty to match runtime library.)")
-if (CLANG_DEFAULT_UNWINDLIB STREQUAL "")
-  if (CLANG_DEFAULT_RTLIB STREQUAL "libgcc")
-    set (CLANG_DEFAULT_UNWINDLIB "libgcc" CACHE STRING "" FORCE)
-  endif()
-endif()
-
-if (NOT(CLANG_DEFAULT_UNWINDLIB STREQUAL "" OR
-        CLANG_DEFAULT_UNWINDLIB STREQUAL "none" OR
-        CLANG_DEFAULT_UNWINDLIB STREQUAL "libgcc" OR
-        CLANG_DEFAULT_UNWINDLIB STREQUAL "libunwind"))
-  message(WARNING "Resetting default unwindlib to use platform default")
-  set(CLANG_DEFAULT_UNWINDLIB "" CACHE STRING
-    "Default unwind library to use (\"none\" \"libgcc\" or \"libunwind\", empty to match runtime library.)" FORCE)
-endif()
-
-set(CLANG_DEFAULT_OBJCOPY "objcopy" CACHE STRING
-  "Default objcopy executable to use.")
-
-set(CLANG_DEFAULT_OPENMP_RUNTIME "libomp" CACHE STRING
-  "Default OpenMP runtime used by -fopenmp.")
-
-# OpenMP offloading requires at least sm_35 because we use shuffle instructions
-# to generate efficient code for reductions and the atomicMax instruction on
-# 64-bit integers in the implementation of conditional lastprivate.
-set(CUDA_ARCH_FLAGS "sm_35")
-
-# Try to find the highest Nvidia GPU architecture the system supports
-if (NOT DEFINED CLANG_OPENMP_NVPTX_DEFAULT_ARCH)
-  find_package(CUDA QUIET)
-  if (CUDA_FOUND)
-    cuda_select_nvcc_arch_flags(CUDA_ARCH_FLAGS)
-  endif()
-else()
-  set(CUDA_ARCH_FLAGS ${CLANG_OPENMP_NVPTX_DEFAULT_ARCH})
-endif()
-
-string(REGEX MATCH "sm_([0-9]+)" CUDA_ARCH_MATCH ${CUDA_ARCH_FLAGS})
-if (NOT DEFINED CUDA_ARCH_MATCH OR "${CMAKE_MATCH_1}" LESS 35)
-  set(CLANG_OPENMP_NVPTX_DEFAULT_ARCH "sm_35" CACHE STRING
-    "Default architecture for OpenMP offloading to Nvidia GPUs." FORCE)
-  message(WARNING "Resetting default architecture for OpenMP offloading to Nvidia GPUs to sm_35")
-else()
-  set(CLANG_OPENMP_NVPTX_DEFAULT_ARCH ${CUDA_ARCH_MATCH} CACHE STRING
-    "Default architecture for OpenMP offloading to Nvidia GPUs.")
-endif()
-
-set(CLANG_SYSTEMZ_DEFAULT_ARCH "z10" CACHE STRING "SystemZ Default Arch")
-
-set(CLANG_VENDOR ${PACKAGE_VENDOR} CACHE STRING
-  "Vendor-specific text for showing with version information.")
-
-set(CLANG_REPOSITORY_STRING "" CACHE STRING
-  "Vendor-specific text for showing the repository the source is taken from.")
-
-if(CLANG_REPOSITORY_STRING)
-  add_definitions(-DCLANG_REPOSITORY_STRING="${CLANG_REPOSITORY_STRING}")
-endif()
-
-set(CLANG_VENDOR_UTI "org.llvm.clang" CACHE STRING
-  "Vendor-specific uti.")
-
-set(CLANG_PYTHON_BINDINGS_VERSIONS "" CACHE STRING
-    "Python versions to install libclang python bindings for")
-
-set(CLANG_LINK_CLANG_DYLIB ${LLVM_LINK_LLVM_DYLIB} CACHE BOOL
-    "Link tools against libclang-cpp.so")
-
-if (NOT LLVM_LINK_LLVM_DYLIB AND CLANG_LINK_CLANG_DYLIB)
-  message(FATAL_ERROR "Cannot set CLANG_LINK_CLANG_DYLIB=ON when "
-                      "LLVM_LINK_LLVM_DYLIB=OFF")
-endif()
-
-# The libdir suffix must exactly match whatever LLVM's configuration used.
-set(CLANG_LIBDIR_SUFFIX "${LLVM_LIBDIR_SUFFIX}")
-
-set(CLANG_SOURCE_DIR ${CMAKE_CURRENT_SOURCE_DIR})
-set(CLANG_BINARY_DIR ${CMAKE_CURRENT_BINARY_DIR})
-
-if( CMAKE_SOURCE_DIR STREQUAL CMAKE_BINARY_DIR AND NOT MSVC_IDE )
-  message(FATAL_ERROR "In-source builds are not allowed. "
-"Please create a directory and run cmake "
-"from there, passing the path to this source directory as the last argument. "
-"This process created the file `CMakeCache.txt' and the directory "
-"`CMakeFiles'. Please delete them.")
-endif()
-
-# If CLANG_VERSION_* is specified, use it, if not use LLVM_VERSION_*.
-if(NOT DEFINED CLANG_VERSION_MAJOR)
-  set(CLANG_VERSION_MAJOR ${LLVM_VERSION_MAJOR})
-endif()
-if(NOT DEFINED CLANG_VERSION_MINOR)
-  set(CLANG_VERSION_MINOR ${LLVM_VERSION_MINOR})
-endif()
-if(NOT DEFINED CLANG_VERSION_PATCHLEVEL)
-  set(CLANG_VERSION_PATCHLEVEL ${LLVM_VERSION_PATCH})
-endif()
-# Unlike PACKAGE_VERSION, CLANG_VERSION does not include LLVM_VERSION_SUFFIX.
-set(CLANG_VERSION "${CLANG_VERSION_MAJOR}.${CLANG_VERSION_MINOR}.${CLANG_VERSION_PATCHLEVEL}")
-message(STATUS "Clang version: ${CLANG_VERSION}")
-
-# Configure the Version.inc file.
-configure_file(
-  ${CMAKE_CURRENT_SOURCE_DIR}/include/clang/Basic/Version.inc.in
-  ${CMAKE_CURRENT_BINARY_DIR}/include/clang/Basic/Version.inc)
-
-# Add appropriate flags for GCC
-if (LLVM_COMPILER_IS_GCC_COMPATIBLE)
-  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fno-common -Woverloaded-virtual")
-  if (NOT "${CMAKE_CXX_COMPILER_ID}" MATCHES "Clang")
-    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fno-strict-aliasing")
-  endif ()
-
-  # Enable -pedantic for Clang even if it's not enabled for LLVM.
-  if (NOT LLVM_ENABLE_PEDANTIC)
-    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -pedantic -Wno-long-long")
-  endif ()
-
-  check_cxx_compiler_flag("-Werror -Wnested-anon-types" CXX_SUPPORTS_NO_NESTED_ANON_TYPES_FLAG)
-  if( CXX_SUPPORTS_NO_NESTED_ANON_TYPES_FLAG )
-    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wno-nested-anon-types" )
-  endif()
-endif ()
-
-# Determine HOST_LINK_VERSION on Darwin.
-set(HOST_LINK_VERSION)
-if (APPLE)
-  set(LD_V_OUTPUT)
-  execute_process(
-    COMMAND sh -c "${CMAKE_LINKER} -v 2>&1 | head -1"
-    RESULT_VARIABLE HAD_ERROR
-    OUTPUT_VARIABLE LD_V_OUTPUT
-  )
-  if (HAD_ERROR)
-    message(FATAL_ERROR "${CMAKE_LINKER} failed with status ${HAD_ERROR}")
-  endif()
-  if ("${LD_V_OUTPUT}" MATCHES ".*ld64-([0-9.]+).*")
-    string(REGEX REPLACE ".*ld64-([0-9.]+).*" "\\1" HOST_LINK_VERSION ${LD_V_OUTPUT})
-  elseif ("${LD_V_OUTPUT}" MATCHES "[^0-9]*([0-9.]+).*")
-    string(REGEX REPLACE "[^0-9]*([0-9.]+).*" "\\1" HOST_LINK_VERSION ${LD_V_OUTPUT})
-  endif()
-  message(STATUS "Host linker version: ${HOST_LINK_VERSION}")
-endif()
-
-include(CMakeParseArguments)
-include(AddClang)
-
-set(CMAKE_INCLUDE_CURRENT_DIR ON)
-
-include_directories(BEFORE
-  ${CMAKE_CURRENT_BINARY_DIR}/include
-  ${CMAKE_CURRENT_SOURCE_DIR}/include
-  )
-
-if (NOT LLVM_INSTALL_TOOLCHAIN_ONLY)
-  install(DIRECTORY include/clang include/clang-c
-    DESTINATION include
-    COMPONENT clang-headers
-    FILES_MATCHING
-    PATTERN "*.def"
-    PATTERN "*.h"
-    PATTERN "config.h" EXCLUDE
-    )
-
-  install(DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/include/clang
-    DESTINATION include
-    COMPONENT clang-headers
-    FILES_MATCHING
-    PATTERN "CMakeFiles" EXCLUDE
-    PATTERN "*.inc"
-    PATTERN "*.h"
-    )
-
-  # Installing the headers needs to depend on generating any public
-  # tablegen'd headers.
-  add_custom_target(clang-headers DEPENDS clang-tablegen-targets)
-  set_target_properties(clang-headers PROPERTIES FOLDER "Misc")
-  if(NOT LLVM_ENABLE_IDE)
-    add_llvm_install_targets(install-clang-headers
-                             DEPENDS clang-headers
-                             COMPONENT clang-headers)
-  endif()
-
-  add_custom_target(bash-autocomplete DEPENDS utils/bash-autocomplete.sh)
-  install(PROGRAMS utils/bash-autocomplete.sh
-          DESTINATION share/clang
-          COMPONENT bash-autocomplete)
-  if(NOT LLVM_ENABLE_IDE)
-    add_llvm_install_targets(install-bash-autocomplete
-                             DEPENDS bash-autocomplete
-                             COMPONENT bash-autocomplete)
-  endif()
-endif()
-
-add_definitions( -D_GNU_SOURCE )
-
-option(CLANG_BUILD_TOOLS
-  "Build the Clang tools. If OFF, just generate build targets." ON)
-
-option(CLANG_ENABLE_ARCMT "Build ARCMT." ON)
-option(CLANG_ENABLE_STATIC_ANALYZER
-  "Include static analyzer in clang binary." ON)
-
-option(CLANG_ENABLE_PROTO_FUZZER "Build Clang protobuf fuzzer." OFF)
-
-option(CLANG_ROUND_TRIP_CC1_ARGS
-  "Round-trip command line arguments in -cc1." ${LLVM_ENABLE_ASSERTIONS})
-
-if(NOT CLANG_ENABLE_STATIC_ANALYZER AND CLANG_ENABLE_ARCMT)
-  message(FATAL_ERROR "Cannot disable static analyzer while enabling ARCMT or Z3")
-endif()
-
-if(CLANG_ENABLE_ARCMT)
-  set(CLANG_ENABLE_OBJC_REWRITER ON)
-endif()
-
-if (CLANG_ROUND_TRIP_CC1_ARGS)
-  add_definitions(-DCLANG_ROUND_TRIP_CC1_ARGS=ON)
-endif()
-
-# Clang version information
-set(CLANG_EXECUTABLE_VERSION
-    "${CLANG_VERSION_MAJOR}" CACHE STRING
-    "Major version number that will be appended to the clang executable name")
-set(LIBCLANG_LIBRARY_VERSION
-    "${CLANG_VERSION_MAJOR}" CACHE STRING
-    "Major version number that will be appended to the libclang library")
-mark_as_advanced(CLANG_EXECUTABLE_VERSION LIBCLANG_LIBRARY_VERSION)
-
-option(CLANG_INCLUDE_TESTS
-       "Generate build targets for the Clang unit tests."
-       ${LLVM_INCLUDE_TESTS})
-
-add_subdirectory(utils/TableGen)
-
-add_subdirectory(include)
-
-# All targets below may depend on all tablegen'd files.
-get_property(CLANG_TABLEGEN_TARGETS GLOBAL PROPERTY CLANG_TABLEGEN_TARGETS)
-add_custom_target(clang-tablegen-targets
-  DEPENDS
-  omp_gen
-  ${CLANG_TABLEGEN_TARGETS})
-set_target_properties(clang-tablegen-targets PROPERTIES FOLDER "Misc")
-list(APPEND LLVM_COMMON_DEPENDS clang-tablegen-targets)
-
-# Force target to be built as soon as possible. Clang modules builds depend
-# header-wise on it as they ship all headers from the umbrella folders. Building
-# an entire module might include header, which depends on intrinsics_gen.
-if(LLVM_ENABLE_MODULES)
-  list(APPEND LLVM_COMMON_DEPENDS intrinsics_gen)
-endif()
-
-add_subdirectory(lib)
-add_subdirectory(tools)
-add_subdirectory(runtime)
-
-option(CLANG_BUILD_EXAMPLES "Build CLANG example programs by default." OFF)
-add_subdirectory(examples)
-
-if(APPLE)
-  # this line is needed as a cleanup to ensure that any CMakeCaches with the old
-  # default value get updated to the new default.
-  if(CLANG_ORDER_FILE STREQUAL "")
-    unset(CLANG_ORDER_FILE CACHE)
-    unset(CLANG_ORDER_FILE)
-  endif()
-
-
-  set(CLANG_ORDER_FILE ${CMAKE_CURRENT_BINARY_DIR}/clang.order CACHE FILEPATH
-    "Order file to use when compiling clang in order to improve startup time (Darwin Only - requires ld64).")
-
-  if(NOT EXISTS ${CLANG_ORDER_FILE})
-    string(FIND "${CLANG_ORDER_FILE}" "${CMAKE_CURRENT_BINARY_DIR}" PATH_START)
-    if(PATH_START EQUAL 0)
-      file(WRITE ${CLANG_ORDER_FILE} "\n")
-    else()
-      message(FATAL_ERROR "Specified order file '${CLANG_ORDER_FILE}' does not exist.")
-    endif()
-  endif()
-endif()
-
-
-if( CLANG_INCLUDE_TESTS )
-  if(EXISTS ${LLVM_MAIN_SRC_DIR}/utils/unittest/googletest/include/gtest/gtest.h)
-    add_subdirectory(unittests)
-    list(APPEND CLANG_TEST_DEPS ClangUnitTests)
-    list(APPEND CLANG_TEST_PARAMS
-      clang_unit_site_config=${CMAKE_CURRENT_BINARY_DIR}/test/Unit/lit.site.cfg
-      )
-  endif()
-  add_subdirectory(test)
-  add_subdirectory(bindings/python/tests)
-
-  if(CLANG_BUILT_STANDALONE)
-    # Add a global check rule now that all subdirectories have been traversed
-    # and we know the total set of lit testsuites.
-    get_property(LLVM_LIT_TESTSUITES GLOBAL PROPERTY LLVM_LIT_TESTSUITES)
-    get_property(LLVM_LIT_PARAMS GLOBAL PROPERTY LLVM_LIT_PARAMS)
-    get_property(LLVM_LIT_DEPENDS GLOBAL PROPERTY LLVM_LIT_DEPENDS)
-    get_property(LLVM_LIT_EXTRA_ARGS GLOBAL PROPERTY LLVM_LIT_EXTRA_ARGS)
-    get_property(LLVM_ADDITIONAL_TEST_TARGETS
-                 GLOBAL PROPERTY LLVM_ADDITIONAL_TEST_TARGETS)
-    add_lit_target(check-all
-      "Running all regression tests"
-      ${LLVM_LIT_TESTSUITES}
-      PARAMS ${LLVM_LIT_PARAMS}
-      DEPENDS ${LLVM_LIT_DEPENDS} ${LLVM_ADDITIONAL_TEST_TARGETS}
-      ARGS ${LLVM_LIT_EXTRA_ARGS}
-      )
-  endif()
-  add_subdirectory(utils/perf-training)
-endif()
-
-option(CLANG_INCLUDE_DOCS "Generate build targets for the Clang docs."
-  ${LLVM_INCLUDE_DOCS})
-if( CLANG_INCLUDE_DOCS )
-  add_subdirectory(docs)
-endif()
-
-# Custom target to install all clang libraries.
-add_custom_target(clang-libraries)
-set_target_properties(clang-libraries PROPERTIES FOLDER "Misc")
-
-if(NOT LLVM_ENABLE_IDE)
-  add_llvm_install_targets(install-clang-libraries
-                           DEPENDS clang-libraries
-                           COMPONENT clang-libraries)
-endif()
-
-get_property(CLANG_LIBS GLOBAL PROPERTY CLANG_LIBS)
-if(CLANG_LIBS)
-  list(REMOVE_DUPLICATES CLANG_LIBS)
-  foreach(lib ${CLANG_LIBS})
-    add_dependencies(clang-libraries ${lib})
-    if(NOT LLVM_ENABLE_IDE)
-      add_dependencies(install-clang-libraries install-${lib})
-      add_dependencies(install-clang-libraries-stripped install-${lib}-stripped)
-    endif()
-  endforeach()
-endif()
-
-add_subdirectory(cmake/modules)
-
-if(CLANG_STAGE)
-  message(STATUS "Setting current clang stage to: ${CLANG_STAGE}")
-endif()
-
-if (CLANG_ENABLE_BOOTSTRAP)
-  include(ExternalProject)
-
-  add_custom_target(clang-bootstrap-deps DEPENDS clang)
-
-  if(NOT CLANG_STAGE)
-    set(CLANG_STAGE stage1)
-  endif()
-
-  string(REGEX MATCH "stage([0-9]*)" MATCHED_STAGE "${CLANG_STAGE}")
-  if(MATCHED_STAGE)
-    if(NOT LLVM_BUILD_INSTRUMENTED)
-      math(EXPR STAGE_NUM "${CMAKE_MATCH_1} + 1")
-      set(NEXT_CLANG_STAGE stage${STAGE_NUM})
-    else()
-      set(NEXT_CLANG_STAGE stage${CMAKE_MATCH_1})
-    endif()
-  else()
-    set(NEXT_CLANG_STAGE bootstrap)
-  endif()
-
-  if(BOOTSTRAP_LLVM_BUILD_INSTRUMENTED)
-    set(NEXT_CLANG_STAGE ${NEXT_CLANG_STAGE}-instrumented)
-  endif()
-  message(STATUS "Setting next clang stage to: ${NEXT_CLANG_STAGE}")
-
-
-  set(STAMP_DIR ${CMAKE_CURRENT_BINARY_DIR}/${NEXT_CLANG_STAGE}-stamps/)
-  set(BINARY_DIR ${CMAKE_CURRENT_BINARY_DIR}/${NEXT_CLANG_STAGE}-bins/)
-
-  if(BOOTSTRAP_LLVM_ENABLE_LLD)
-    # adding lld to clang-bootstrap-deps without having it enabled in
-    # LLVM_ENABLE_PROJECTS just generates a cryptic error message.
-    if (NOT "lld" IN_LIST LLVM_ENABLE_PROJECTS)
-      message(FATAL_ERROR "LLD is enabled in the boostrap build, but lld is not in LLVM_ENABLE_PROJECTS")
-    endif()
-    add_dependencies(clang-bootstrap-deps lld)
-  endif()
-
-  # If the next stage is LTO we need to depend on LTO and possibly lld or LLVMgold
-  if(BOOTSTRAP_LLVM_ENABLE_LTO OR LLVM_ENABLE_LTO AND NOT LLVM_BUILD_INSTRUMENTED)
-    if(APPLE)
-      add_dependencies(clang-bootstrap-deps LTO)
-      # on Darwin we need to set DARWIN_LTO_LIBRARY so that -flto will work
-      # using the just-built compiler, and we need to override DYLD_LIBRARY_PATH
-      # so that the host object file tools will use the just-built libLTO.
-      # However if System Integrity Protection is enabled the DYLD variables
-      # will be scrubbed from the environment of any base system commands. This
-      # includes /bin/sh, which ninja uses when executing build commands. To
-      # work around the envar being filtered away we pass it in as a CMake
-      # variable, and have LLVM's CMake append the envar to the archiver calls.
-      set(LTO_LIBRARY -DDARWIN_LTO_LIBRARY=${LLVM_SHLIB_OUTPUT_INTDIR}/libLTO.dylib
-        -DDYLD_LIBRARY_PATH=${LLVM_LIBRARY_OUTPUT_INTDIR})
-    elseif(NOT WIN32)
-      add_dependencies(clang-bootstrap-deps llvm-ar llvm-ranlib)
-      if(NOT BOOTSTRAP_LLVM_ENABLE_LLD AND LLVM_BINUTILS_INCDIR)
-        add_dependencies(clang-bootstrap-deps LLVMgold)
-      endif()
-      set(${CLANG_STAGE}_AR -DCMAKE_AR=${LLVM_RUNTIME_OUTPUT_INTDIR}/llvm-ar)
-      set(${CLANG_STAGE}_RANLIB -DCMAKE_RANLIB=${LLVM_RUNTIME_OUTPUT_INTDIR}/llvm-ranlib)
-    endif()
-  endif()
-
-  if(CLANG_BOOTSTRAP_EXTRA_DEPS)
-    add_dependencies(clang-bootstrap-deps ${CLANG_BOOTSTRAP_EXTRA_DEPS})
-  endif()
-
-  add_custom_target(${NEXT_CLANG_STAGE}-clear
-    DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/${NEXT_CLANG_STAGE}-cleared
-    )
-  add_custom_command(
-    OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/${NEXT_CLANG_STAGE}-cleared
-    DEPENDS clang-bootstrap-deps
-    COMMAND ${CMAKE_COMMAND} -E remove_directory ${BINARY_DIR}
-    COMMAND ${CMAKE_COMMAND} -E make_directory ${BINARY_DIR}
-    COMMAND ${CMAKE_COMMAND} -E remove_directory ${STAMP_DIR}
-    COMMAND ${CMAKE_COMMAND} -E make_directory ${STAMP_DIR}
-    COMMENT "Clobberring ${NEXT_CLANG_STAGE} build and stamp directories"
-    )
-
-  if(CMAKE_VERBOSE_MAKEFILE)
-    set(verbose -DCMAKE_VERBOSE_MAKEFILE=On)
-  endif()
-
-  set(_BOOTSTRAP_DEFAULT_PASSTHROUGH
-    PACKAGE_VERSION
-    PACKAGE_VENDOR
-    LLVM_VERSION_MAJOR
-    LLVM_VERSION_MINOR
-    LLVM_VERSION_PATCH
-    CLANG_VERSION_MAJOR
-    CLANG_VERSION_MINOR
-    CLANG_VERSION_PATCHLEVEL
-    CLANG_VENDOR
-    LLVM_VERSION_SUFFIX
-    LLVM_BINUTILS_INCDIR
-    CLANG_REPOSITORY_STRING
-    CMAKE_C_COMPILER_LAUNCHER
-    CMAKE_CXX_COMPILER_LAUNCHER
-    CMAKE_MAKE_PROGRAM
-    CMAKE_OSX_ARCHITECTURES
-    LLVM_ENABLE_PROJECTS
-    LLVM_ENABLE_RUNTIMES)
-
-  # We don't need to depend on compiler-rt/libcxx if we're building instrumented
-  # because the next stage will use the same compiler used to build this stage.
-  if(NOT LLVM_BUILD_INSTRUMENTED)
-    if(TARGET compiler-rt)
-      add_dependencies(clang-bootstrap-deps compiler-rt)
-    endif()
-    if(TARGET cxx-headers)
-      add_dependencies(clang-bootstrap-deps cxx-headers)
-    endif()
-  endif()
-
-  set(C_COMPILER "clang")
-  set(CXX_COMPILER "clang++")
-  if(WIN32)
-    set(C_COMPILER "clang-cl.exe")
-    set(CXX_COMPILER "clang-cl.exe")
-  endif()
-
-  set(COMPILER_OPTIONS
-    -DCMAKE_CXX_COMPILER=${LLVM_RUNTIME_OUTPUT_INTDIR}/${CXX_COMPILER}
-    -DCMAKE_C_COMPILER=${LLVM_RUNTIME_OUTPUT_INTDIR}/${C_COMPILER}
-    -DCMAKE_ASM_COMPILER=${LLVM_RUNTIME_OUTPUT_INTDIR}/${C_COMPILER}
-    -DCMAKE_ASM_COMPILER_ID=Clang)
-
-  # cmake requires CMAKE_LINKER to be specified if the compiler is MSVC-like,
-  # otherwise it defaults the linker to be link.exe.
-  if(BOOTSTRAP_LLVM_ENABLE_LLD)
-    if((WIN32 AND NOT BOOTSTRAP_CMAKE_SYSTEM_NAME) OR BOOTSTRAP_CMAKE_SYSTEM_NAME STREQUAL "Windows")
-      set(${CLANG_STAGE}_LINKER -DCMAKE_LINKER=${LLVM_RUNTIME_OUTPUT_INTDIR}/lld-link${CMAKE_EXECUTABLE_SUFFIX})
-    endif()
-  endif()
-
-  if(BOOTSTRAP_CMAKE_SYSTEM_NAME)
-    set(${CLANG_STAGE}_CONFIG -DLLVM_CONFIG_PATH=${LLVM_RUNTIME_OUTPUT_INTDIR}/llvm-config)
-    set(${CLANG_STAGE}_TABLEGEN
-      -DLLVM_TABLEGEN=${LLVM_RUNTIME_OUTPUT_INTDIR}/llvm-tblgen
-      -DCLANG_TABLEGEN=${LLVM_RUNTIME_OUTPUT_INTDIR}/clang-tblgen)
-    if(BOOTSTRAP_CMAKE_SYSTEM_NAME STREQUAL "Linux")
-      if(BOOTSTRAP_LLVM_ENABLE_LLD)
-        set(${CLANG_STAGE}_LINKER -DCMAKE_LINKER=${LLVM_RUNTIME_OUTPUT_INTDIR}/ld.lld)
-      endif()
-      if(NOT BOOTSTRAP_LLVM_ENABLE_LTO)
-        add_dependencies(clang-bootstrap-deps llvm-ar llvm-ranlib)
-        set(${CLANG_STAGE}_AR -DCMAKE_AR=${LLVM_RUNTIME_OUTPUT_INTDIR}/llvm-ar)
-        set(${CLANG_STAGE}_RANLIB -DCMAKE_RANLIB=${LLVM_RUNTIME_OUTPUT_INTDIR}/llvm-ranlib)
-      endif()
-      add_dependencies(clang-bootstrap-deps llvm-objcopy llvm-strip)
-      set(${CLANG_STAGE}_OBJCOPY -DCMAKE_OBJCOPY=${LLVM_RUNTIME_OUTPUT_INTDIR}/llvm-objcopy)
-      set(${CLANG_STAGE}_STRIP -DCMAKE_STRIP=${LLVM_RUNTIME_OUTPUT_INTDIR}/llvm-strip)
-    endif()
-  endif()
-
-  if(BOOTSTRAP_LLVM_BUILD_INSTRUMENTED)
-    add_dependencies(clang-bootstrap-deps llvm-profdata)
-    set(PGO_OPT -DLLVM_PROFDATA=${LLVM_RUNTIME_OUTPUT_INTDIR}/llvm-profdata)
-  endif()
-
-  if(LLVM_BUILD_INSTRUMENTED)
-    add_dependencies(clang-bootstrap-deps generate-profdata)
-    set(PGO_OPT -DLLVM_PROFDATA_FILE=${CMAKE_CURRENT_BINARY_DIR}/utils/perf-training/clang.profdata)
-    # Use the current tools for LTO instead of the instrumented ones
-    list(APPEND _BOOTSTRAP_DEFAULT_PASSTHROUGH
-      CMAKE_CXX_COMPILER
-      CMAKE_C_COMPILER
-      CMAKE_ASM_COMPILER
-      CMAKE_AR
-      CMAKE_RANLIB
-      DARWIN_LTO_LIBRARY
-      DYLD_LIBRARY_PATH)
-
-    set(COMPILER_OPTIONS)
-    set(LTO_LIBRARY)
-    set(LTO_AR)
-    set(LTO_RANLIB)
-  endif()
-
-  # Find all variables that start with BOOTSTRAP_ and populate a variable with
-  # them.
-  get_cmake_property(variableNames VARIABLES)
-  foreach(variableName ${variableNames})
-    if(variableName MATCHES "^BOOTSTRAP_")
-      string(SUBSTRING ${variableName} 10 -1 varName)
-      string(REPLACE ";" "|" value "${${variableName}}")
-      list(APPEND PASSTHROUGH_VARIABLES
-        -D${varName}=${value})
-    endif()
-    if(${variableName} AND variableName MATCHES "LLVM_EXTERNAL_.*_SOURCE_DIR")
-      list(APPEND PASSTHROUGH_VARIABLES
-        -D${variableName}=${${variableName}})
-    endif()
-  endforeach()
-
-  # Populate the passthrough variables
-  foreach(variableName ${CLANG_BOOTSTRAP_PASSTHROUGH} ${_BOOTSTRAP_DEFAULT_PASSTHROUGH})
-    if(DEFINED ${variableName})
-      if("${${variableName}}" STREQUAL "")
-        set(value "")
-      else()
-        string(REPLACE ";" "|" value "${${variableName}}")
-      endif()
-      list(APPEND PASSTHROUGH_VARIABLES
-        -D${variableName}=${value})
-    endif()
-  endforeach()
-
-  ExternalProject_Add(${NEXT_CLANG_STAGE}
-    DEPENDS clang-bootstrap-deps
-    PREFIX ${NEXT_CLANG_STAGE}
-    SOURCE_DIR ${CMAKE_SOURCE_DIR}
-    STAMP_DIR ${STAMP_DIR}
-    BINARY_DIR ${BINARY_DIR}
-    EXCLUDE_FROM_ALL 1
-    CMAKE_ARGS
-                # We shouldn't need to set this here, but INSTALL_DIR doesn't
-                # seem to work, so instead I'm passing this through
-                -DCMAKE_INSTALL_PREFIX=${CMAKE_INSTALL_PREFIX}
-                ${PASSTHROUGH_VARIABLES}
-                ${CLANG_BOOTSTRAP_CMAKE_ARGS}
-                 -DCLANG_STAGE=${NEXT_CLANG_STAGE}
-                ${COMPILER_OPTIONS}
-                ${${CLANG_STAGE}_CONFIG}
-                ${${CLANG_STAGE}_TABLEGEN}
-                ${LTO_LIBRARY} ${verbose} ${PGO_OPT}
-                ${${CLANG_STAGE}_LINKER}
-                ${${CLANG_STAGE}_AR}
-                ${${CLANG_STAGE}_RANLIB}
-                ${${CLANG_STAGE}_OBJCOPY}
-                ${${CLANG_STAGE}_STRIP}
-    INSTALL_COMMAND ""
-    STEP_TARGETS configure build
-    USES_TERMINAL_CONFIGURE 1
-    USES_TERMINAL_BUILD 1
-    USES_TERMINAL_INSTALL 1
-    LIST_SEPARATOR |
-    )
-
-  # exclude really-install from main target
-  set_target_properties(${NEXT_CLANG_STAGE} PROPERTIES _EP_really-install_EXCLUDE_FROM_MAIN On)
-  ExternalProject_Add_Step(${NEXT_CLANG_STAGE} really-install
-    COMMAND ${CMAKE_COMMAND} --build <BINARY_DIR> --target install
-    COMMENT "Performing install step for '${NEXT_CLANG_STAGE}'"
-    DEPENDEES build
-    USES_TERMINAL 1
-  )
-  ExternalProject_Add_StepTargets(${NEXT_CLANG_STAGE} really-install)
-  add_custom_target(${NEXT_CLANG_STAGE}-install DEPENDS ${NEXT_CLANG_STAGE}-really-install)
-
-  if(NOT CLANG_BOOTSTRAP_TARGETS)
-    set(CLANG_BOOTSTRAP_TARGETS check-llvm check-clang check-all)
-  endif()
-  foreach(target ${CLANG_BOOTSTRAP_TARGETS})
-    # Install targets have side effects, so we always want to execute them.
-    # "install" is reserved by CMake and can't be used as a step name for
-    # ExternalProject_Add_Step, so we can match against "^install-" instead of
-    # "^install" to get a tighter match. CMake's installation scripts already
-    # skip up-to-date files, so there's no behavior change if you install to the
-    # same destination multiple times.
-    if(target MATCHES "^install-")
-      set(step_always ON)
-    else()
-      set(step_always OFF)
-    endif()
-
-    ExternalProject_Add_Step(${NEXT_CLANG_STAGE} ${target}
-      COMMAND ${CMAKE_COMMAND} --build <BINARY_DIR> --target ${target}
-      COMMENT "Performing ${target} for '${NEXT_CLANG_STAGE}'"
-      DEPENDEES configure
-      ALWAYS ${step_always}
-      EXCLUDE_FROM_MAIN ON
-      USES_TERMINAL 1
-    )
-
-    if(target MATCHES "^stage[0-9]*")
-      add_custom_target(${target} DEPENDS ${NEXT_CLANG_STAGE}-${target})
-    endif()
-
-    ExternalProject_Add_StepTargets(${NEXT_CLANG_STAGE} ${target})
-  endforeach()
-endif()
-
-if (LLVM_ADD_NATIVE_VISUALIZERS_TO_SOLUTION)
-  add_subdirectory(utils/ClangVisualizers)
-endif()
-add_subdirectory(utils/hmaptool)
-
-if(CLANG_BUILT_STANDALONE)
-  llvm_distribution_add_targets()
-  process_llvm_pass_plugins()
-endif()
-
-configure_file(
-  ${CLANG_SOURCE_DIR}/include/clang/Config/config.h.cmake
-  ${CLANG_BINARY_DIR}/include/clang/Config/config.h)
diff -uNr llvm-toolchain-14-14.0.6.orig/clang/docs/CommandGuide/clang.rst.orig llvm-toolchain-14-14.0.6/clang/docs/CommandGuide/clang.rst.orig
--- llvm-toolchain-14-14.0.6.orig/clang/docs/CommandGuide/clang.rst.orig	2022-01-23 08:27:11.000000000 +0800
+++ llvm-toolchain-14-14.0.6/clang/docs/CommandGuide/clang.rst.orig	1970-01-01 08:00:00.000000000 +0800
@@ -1,672 +0,0 @@
-clang - the Clang C, C++, and Objective-C compiler
-==================================================
-
-SYNOPSIS
---------
-
-:program:`clang` [*options*] *filename ...*
-
-DESCRIPTION
------------
-
-:program:`clang` is a C, C++, and Objective-C compiler which encompasses
-preprocessing, parsing, optimization, code generation, assembly, and linking.
-Depending on which high-level mode setting is passed, Clang will stop before
-doing a full link.  While Clang is highly integrated, it is important to
-understand the stages of compilation, to understand how to invoke it.  These
-stages are:
-
-Driver
-    The clang executable is actually a small driver which controls the overall
-    execution of other tools such as the compiler, assembler and linker.
-    Typically you do not need to interact with the driver, but you
-    transparently use it to run the other tools.
-
-Preprocessing
-    This stage handles tokenization of the input source file, macro expansion,
-    #include expansion and handling of other preprocessor directives.  The
-    output of this stage is typically called a ".i" (for C), ".ii" (for C++),
-    ".mi" (for Objective-C), or ".mii" (for Objective-C++) file.
-
-Parsing and Semantic Analysis
-    This stage parses the input file, translating preprocessor tokens into a
-    parse tree.  Once in the form of a parse tree, it applies semantic
-    analysis to compute types for expressions as well and determine whether
-    the code is well formed. This stage is responsible for generating most of
-    the compiler warnings as well as parse errors. The output of this stage is
-    an "Abstract Syntax Tree" (AST).
-
-Code Generation and Optimization
-    This stage translates an AST into low-level intermediate code (known as
-    "LLVM IR") and ultimately to machine code.  This phase is responsible for
-    optimizing the generated code and handling target-specific code generation.
-    The output of this stage is typically called a ".s" file or "assembly" file.
-
-    Clang also supports the use of an integrated assembler, in which the code
-    generator produces object files directly. This avoids the overhead of
-    generating the ".s" file and of calling the target assembler.
-
-Assembler
-    This stage runs the target assembler to translate the output of the
-    compiler into a target object file. The output of this stage is typically
-    called a ".o" file or "object" file.
-
-Linker
-    This stage runs the target linker to merge multiple object files into an
-    executable or dynamic library. The output of this stage is typically called
-    an "a.out", ".dylib" or ".so" file.
-
-:program:`Clang Static Analyzer`
-
-The Clang Static Analyzer is a tool that scans source code to try to find bugs
-through code analysis.  This tool uses many parts of Clang and is built into
-the same driver.  Please see <https://clang-analyzer.llvm.org> for more details
-on how to use the static analyzer.
-
-OPTIONS
--------
-
-Stage Selection Options
-~~~~~~~~~~~~~~~~~~~~~~~
-
-.. option:: -E
-
- Run the preprocessor stage.
-
-.. option:: -fsyntax-only
-
- Run the preprocessor, parser and type checking stages.
-
-.. option:: -S
-
- Run the previous stages as well as LLVM generation and optimization stages
- and target-specific code generation, producing an assembly file.
-
-.. option:: -c
-
- Run all of the above, plus the assembler, generating a target ".o" object file.
-
-.. option:: no stage selection option
-
- If no stage selection option is specified, all stages above are run, and the
- linker is run to combine the results into an executable or shared library.
-
-Language Selection and Mode Options
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-.. option:: -x <language>
-
- Treat subsequent input files as having type language.
-
-.. option:: -std=<standard>
-
- Specify the language standard to compile for.
-
- Supported values for the C language are:
-
-  | ``c89``
-  | ``c90``
-  | ``iso9899:1990``
-
-   ISO C 1990
-
-  | ``iso9899:199409``
-
-   ISO C 1990 with amendment 1
-
-  | ``gnu89``
-  | ``gnu90``
-
-   ISO C 1990 with GNU extensions
-
-  | ``c99``
-  | ``iso9899:1999``
-
-   ISO C 1999
-
-  | ``gnu99``
-
-   ISO C 1999 with GNU extensions
-
-  | ``c11``
-  | ``iso9899:2011``
-
-   ISO C 2011
-
-  | ``gnu11``
-
-   ISO C 2011 with GNU extensions
-
-  | ``c17``
-  | ``iso9899:2017``
-
-   ISO C 2017
-
-  | ``gnu17``
-
-   ISO C 2017 with GNU extensions
-
- The default C language standard is ``gnu17``, except on PS4, where it is
- ``gnu99``.
-
- Supported values for the C++ language are:
-
-  | ``c++98``
-  | ``c++03``
-
-   ISO C++ 1998 with amendments
-
-  | ``gnu++98``
-  | ``gnu++03``
-
-   ISO C++ 1998 with amendments and GNU extensions
-
-  | ``c++11``
-
-   ISO C++ 2011 with amendments
-
-  | ``gnu++11``
-
-    ISO C++ 2011 with amendments and GNU extensions
-
-  | ``c++14``
-
-   ISO C++ 2014 with amendments
-
-  | ``gnu++14``
-
-   ISO C++ 2014 with amendments and GNU extensions
-
-  | ``c++17``
-
-   ISO C++ 2017 with amendments
-
-  | ``gnu++17``
-
-   ISO C++ 2017 with amendments and GNU extensions
-
-  | ``c++2a``
-
-   Working draft for ISO C++ 2020
-
-  | ``gnu++2a``
-
-   Working draft for ISO C++ 2020 with GNU extensions
-
- The default C++ language standard is ``gnu++14``.
-
- Supported values for the OpenCL language are:
-
-  | ``cl1.0``
-
-   OpenCL 1.0
-
-  | ``cl1.1``
-
-   OpenCL 1.1
-
-  | ``cl1.2``
-
-   OpenCL 1.2
-
-  | ``cl2.0``
-
-   OpenCL 2.0
-
- The default OpenCL language standard is ``cl1.0``.
-
- Supported values for the CUDA language are:
-
-  | ``cuda``
-
-   NVIDIA CUDA(tm)
-
-.. option:: -stdlib=<library>
-
- Specify the C++ standard library to use; supported options are libstdc++ and
- libc++. If not specified, platform default will be used.
-
-.. option:: -rtlib=<library>
-
- Specify the compiler runtime library to use; supported options are libgcc and
- compiler-rt. If not specified, platform default will be used.
-
-.. option:: -ansi
-
- Same as -std=c89.
-
-.. option:: -ObjC, -ObjC++
-
- Treat source input files as Objective-C and Object-C++ inputs respectively.
-
-.. option:: -trigraphs
-
- Enable trigraphs.
-
-.. option:: -ffreestanding
-
- Indicate that the file should be compiled for a freestanding, not a hosted,
- environment. Note that it is assumed that a freestanding environment will
- additionally provide `memcpy`, `memmove`, `memset` and `memcmp`
- implementations, as these are needed for efficient codegen for many programs.
-
-.. option:: -fno-builtin
-
- Disable special handling and optimizations of builtin functions like
- :c:func:`strlen` and :c:func:`malloc`.
-
-.. option:: -fmath-errno
-
- Indicate that math functions should be treated as updating :c:data:`errno`.
-
-.. option:: -fpascal-strings
-
- Enable support for Pascal-style strings with "\\pfoo".
-
-.. option:: -fms-extensions
-
- Enable support for Microsoft extensions.
-
-.. option:: -fmsc-version=
-
- Set _MSC_VER. Defaults to 1300 on Windows. Not set otherwise.
-
-.. option:: -fborland-extensions
-
- Enable support for Borland extensions.
-
-.. option:: -fwritable-strings
-
- Make all string literals default to writable.  This disables uniquing of
- strings and other optimizations.
-
-.. option:: -flax-vector-conversions, -flax-vector-conversions=<kind>, -fno-lax-vector-conversions
-
- Allow loose type checking rules for implicit vector conversions.
- Possible values of <kind>:
-
- - ``none``: allow no implicit conversions between vectors
- - ``integer``: allow implicit bitcasts between integer vectors of the same
-   overall bit-width
- - ``all``: allow implicit bitcasts between any vectors of the same
-   overall bit-width
-
- <kind> defaults to ``integer`` if unspecified.
-
-.. option:: -fblocks
-
- Enable the "Blocks" language feature.
-
-.. option:: -fobjc-abi-version=version
-
- Select the Objective-C ABI version to use. Available versions are 1 (legacy
- "fragile" ABI), 2 (non-fragile ABI 1), and 3 (non-fragile ABI 2).
-
-.. option:: -fobjc-nonfragile-abi-version=<version>
-
- Select the Objective-C non-fragile ABI version to use by default. This will
- only be used as the Objective-C ABI when the non-fragile ABI is enabled
- (either via :option:`-fobjc-nonfragile-abi`, or because it is the platform
- default).
-
-.. option:: -fobjc-nonfragile-abi, -fno-objc-nonfragile-abi
-
- Enable use of the Objective-C non-fragile ABI. On platforms for which this is
- the default ABI, it can be disabled with :option:`-fno-objc-nonfragile-abi`.
-
-Target Selection Options
-~~~~~~~~~~~~~~~~~~~~~~~~
-
-Clang fully supports cross compilation as an inherent part of its design.
-Depending on how your version of Clang is configured, it may have support for a
-number of cross compilers, or may only support a native target.
-
-.. option:: -arch <architecture>
-
-  Specify the architecture to build for.
-
-.. option:: -mmacosx-version-min=<version>
-
-  When building for macOS, specify the minimum version supported by your
-  application.
-
-.. option:: -miphoneos-version-min
-
-  When building for iPhone OS, specify the minimum version supported by your
-  application.
-
-.. option:: --print-supported-cpus
-
-  Print out a list of supported processors for the given target (specified
-  through ``--target=<architecture>`` or :option:`-arch` ``<architecture>``). If no
-  target is specified, the system default target will be used.
-
-.. option:: -mcpu=?, -mtune=?
-
-  Acts as an alias for :option:`--print-supported-cpus`.
-
-.. option:: -march=<cpu>
-
-  Specify that Clang should generate code for a specific processor family
-  member and later.  For example, if you specify -march=i486, the compiler is
-  allowed to generate instructions that are valid on i486 and later processors,
-  but which may not exist on earlier ones.
-
-
-Code Generation Options
-~~~~~~~~~~~~~~~~~~~~~~~
-
-.. option:: -O0, -O1, -O2, -O3, -Ofast, -Os, -Oz, -Og, -O, -O4
-
-  Specify which optimization level to use:
-
-    :option:`-O0` Means "no optimization": this level compiles the fastest and
-    generates the most debuggable code.
-
-    :option:`-O1` Somewhere between :option:`-O0` and :option:`-O2`.
-
-    :option:`-O2` Moderate level of optimization which enables most
-    optimizations.
-
-    :option:`-O3` Like :option:`-O2`, except that it enables optimizations that
-    take longer to perform or that may generate larger code (in an attempt to
-    make the program run faster).
-
-    :option:`-Ofast` Enables all the optimizations from :option:`-O3` along
-    with other aggressive optimizations that may violate strict compliance with
-    language standards.
-
-    :option:`-Os` Like :option:`-O2` with extra optimizations to reduce code
-    size.
-
-    :option:`-Oz` Like :option:`-Os` (and thus :option:`-O2`), but reduces code
-    size further.
-
-    :option:`-Og` Like :option:`-O1`. In future versions, this option might
-    disable different optimizations in order to improve debuggability.
-
-    :option:`-O` Equivalent to :option:`-O1`.
-
-    :option:`-O4` and higher
-
-      Currently equivalent to :option:`-O3`
-
-.. option:: -g, -gline-tables-only, -gmodules
-
-  Control debug information output.  Note that Clang debug information works
-  best at :option:`-O0`.  When more than one option starting with `-g` is
-  specified, the last one wins:
-
-    :option:`-g` Generate debug information.
-
-    :option:`-gline-tables-only` Generate only line table debug information. This
-    allows for symbolicated backtraces with inlining information, but does not
-    include any information about variables, their locations or types.
-
-    :option:`-gmodules` Generate debug information that contains external
-    references to types defined in Clang modules or precompiled headers instead
-    of emitting redundant debug type information into every object file.  This
-    option transparently switches the Clang module format to object file
-    containers that hold the Clang module together with the debug information.
-    When compiling a program that uses Clang modules or precompiled headers,
-    this option produces complete debug information with faster compile
-    times and much smaller object files.
-
-    This option should not be used when building static libraries for
-    distribution to other machines because the debug info will contain
-    references to the module cache on the machine the object files in the
-    library were built on.
-
-.. option:: -fstandalone-debug -fno-standalone-debug
-
-  Clang supports a number of optimizations to reduce the size of debug
-  information in the binary. They work based on the assumption that the
-  debug type information can be spread out over multiple compilation units.
-  For instance, Clang will not emit type definitions for types that are not
-  needed by a module and could be replaced with a forward declaration.
-  Further, Clang will only emit type info for a dynamic C++ class in the
-  module that contains the vtable for the class.
-
-  The :option:`-fstandalone-debug` option turns off these optimizations.
-  This is useful when working with 3rd-party libraries that don't come with
-  debug information.  This is the default on Darwin.  Note that Clang will
-  never emit type information for types that are not referenced at all by the
-  program.
-
-.. option:: -feliminate-unused-debug-types
-
-  By default, Clang does not emit type information for types that are defined
-  but not used in a program. To retain the debug info for these unused types,
-  the negation **-fno-eliminate-unused-debug-types** can be used.
-
-.. option:: -fexceptions
-
-  Enable generation of unwind information. This allows exceptions to be thrown
-  through Clang compiled stack frames.  This is on by default in x86-64.
-
-.. option:: -ftrapv
-
-  Generate code to catch integer overflow errors.  Signed integer overflow is
-  undefined in C. With this flag, extra code is generated to detect this and
-  abort when it happens.
-
-.. option:: -fvisibility
-
-  This flag sets the default visibility level.
-
-.. option:: -fcommon, -fno-common
-
-  This flag specifies that variables without initializers get common linkage.
-  It can be disabled with :option:`-fno-common`.
-
-.. option:: -ftls-model=<model>
-
-  Set the default thread-local storage (TLS) model to use for thread-local
-  variables. Valid values are: "global-dynamic", "local-dynamic",
-  "initial-exec" and "local-exec". The default is "global-dynamic". The default
-  model can be overridden with the tls_model attribute. The compiler will try
-  to choose a more efficient model if possible.
-
-.. option:: -flto, -flto=full, -flto=thin, -emit-llvm
-
-  Generate output files in LLVM formats, suitable for link time optimization.
-  When used with :option:`-S` this generates LLVM intermediate language
-  assembly files, otherwise this generates LLVM bitcode format object files
-  (which may be passed to the linker depending on the stage selection options).
-
-  The default for :option:`-flto` is "full", in which the
-  LLVM bitcode is suitable for monolithic Link Time Optimization (LTO), where
-  the linker merges all such modules into a single combined module for
-  optimization. With "thin", :doc:`ThinLTO <../ThinLTO>`
-  compilation is invoked instead.
-
-  .. note::
-
-     On Darwin, when using :option:`-flto` along with :option:`-g` and
-     compiling and linking in separate steps, you also need to pass
-     ``-Wl,-object_path_lto,<lto-filename>.o`` at the linking step to instruct the
-     ld64 linker not to delete the temporary object file generated during Link
-     Time Optimization (this flag is automatically passed to the linker by Clang
-     if compilation and linking are done in a single step). This allows debugging
-     the executable as well as generating the ``.dSYM`` bundle using :manpage:`dsymutil(1)`.
-
-Driver Options
-~~~~~~~~~~~~~~
-
-.. option:: -###
-
-  Print (but do not run) the commands to run for this compilation.
-
-.. option:: --help
-
-  Display available options.
-
-.. option:: -Qunused-arguments
-
-  Do not emit any warnings for unused driver arguments.
-
-.. option:: -Wa,<args>
-
-  Pass the comma separated arguments in args to the assembler.
-
-.. option:: -Wl,<args>
-
-  Pass the comma separated arguments in args to the linker.
-
-.. option:: -Wp,<args>
-
-  Pass the comma separated arguments in args to the preprocessor.
-
-.. option:: -Xanalyzer <arg>
-
-  Pass arg to the static analyzer.
-
-.. option:: -Xassembler <arg>
-
-  Pass arg to the assembler.
-
-.. option:: -Xlinker <arg>
-
-  Pass arg to the linker.
-
-.. option:: -Xpreprocessor <arg>
-
-  Pass arg to the preprocessor.
-
-.. option:: -o <file>
-
-  Write output to file.
-
-.. option:: -print-file-name=<file>
-
-  Print the full library path of file.
-
-.. option:: -print-libgcc-file-name
-
-  Print the library path for the currently used compiler runtime library
-  ("libgcc.a" or "libclang_rt.builtins.*.a").
-
-.. option:: -print-prog-name=<name>
-
-  Print the full program path of name.
-
-.. option:: -print-search-dirs
-
-  Print the paths used for finding libraries and programs.
-
-.. option:: -save-temps
-
-  Save intermediate compilation results.
-
-.. option:: -save-stats, -save-stats=cwd, -save-stats=obj
-
-  Save internal code generation (LLVM) statistics to a file in the current
-  directory (:option:`-save-stats`/"-save-stats=cwd") or the directory
-  of the output file ("-save-state=obj").
-
-.. option:: -integrated-as, -no-integrated-as
-
-  Used to enable and disable, respectively, the use of the integrated
-  assembler. Whether the integrated assembler is on by default is target
-  dependent.
-
-.. option:: -time
-
-  Time individual commands.
-
-.. option:: -ftime-report
-
-  Print timing summary of each stage of compilation.
-
-.. option:: -v
-
-  Show commands to run and use verbose output.
-
-
-Diagnostics Options
-~~~~~~~~~~~~~~~~~~~
-
-.. option:: -fshow-column, -fshow-source-location, -fcaret-diagnostics, -fdiagnostics-fixit-info, -fdiagnostics-parseable-fixits, -fdiagnostics-print-source-range-info, -fprint-source-range-info, -fdiagnostics-show-option, -fmessage-length
-
-  These options control how Clang prints out information about diagnostics
-  (errors and warnings). Please see the Clang User's Manual for more information.
-
-Preprocessor Options
-~~~~~~~~~~~~~~~~~~~~
-
-.. option:: -D<macroname>=<value>
-
-  Adds an implicit #define into the predefines buffer which is read before the
-  source file is preprocessed.
-
-.. option:: -U<macroname>
-
-  Adds an implicit #undef into the predefines buffer which is read before the
-  source file is preprocessed.
-
-.. option:: -include <filename>
-
-  Adds an implicit #include into the predefines buffer which is read before the
-  source file is preprocessed.
-
-.. option:: -I<directory>
-
-  Add the specified directory to the search path for include files.
-
-.. option:: -F<directory>
-
-  Add the specified directory to the search path for framework include files.
-
-.. option:: -nostdinc
-
-  Do not search the standard system directories or compiler builtin directories
-  for include files.
-
-.. option:: -nostdlibinc
-
-  Do not search the standard system directories for include files, but do
-  search compiler builtin include directories.
-
-.. option:: -nobuiltininc
-
-  Do not search clang's builtin directory for include files.
-
-
-ENVIRONMENT
------------
-
-.. envvar:: TMPDIR, TEMP, TMP
-
-  These environment variables are checked, in order, for the location to write
-  temporary files used during the compilation process.
-
-.. envvar:: CPATH
-
-  If this environment variable is present, it is treated as a delimited list of
-  paths to be added to the default system include path list. The delimiter is
-  the platform dependent delimiter, as used in the PATH environment variable.
-
-  Empty components in the environment variable are ignored.
-
-.. envvar:: C_INCLUDE_PATH, OBJC_INCLUDE_PATH, CPLUS_INCLUDE_PATH, OBJCPLUS_INCLUDE_PATH
-
-  These environment variables specify additional paths, as for :envvar:`CPATH`, which are
-  only used when processing the appropriate language.
-
-.. envvar:: MACOSX_DEPLOYMENT_TARGET
-
-  If :option:`-mmacosx-version-min` is unspecified, the default deployment
-  target is read from this environment variable. This option only affects
-  Darwin targets.
-
-BUGS
-----
-
-To report bugs, please visit <https://github.com/llvm/llvm-project/issues/>.  Most bug reports should
-include preprocessed source files (use the :option:`-E` option) and the full
-output of the compiler, along with information to reproduce.
-
-SEE ALSO
---------
-
-:manpage:`as(1)`, :manpage:`ld(1)`
diff -uNr llvm-toolchain-14-14.0.6.orig/clang/include/clang/Basic/BuiltinsLoongArch.def llvm-toolchain-14-14.0.6/clang/include/clang/Basic/BuiltinsLoongArch.def
--- llvm-toolchain-14-14.0.6.orig/clang/include/clang/Basic/BuiltinsLoongArch.def	1970-01-01 08:00:00.000000000 +0800
+++ llvm-toolchain-14-14.0.6/clang/include/clang/Basic/BuiltinsLoongArch.def	2023-03-09 13:35:06.256286443 +0800
@@ -0,0 +1,56 @@
+//===-- BuiltinsLoongArch.def - LoongArch Builtin function database --------*- C++ -*-==//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file defines the LoongArch-specific builtin function database. Users of
+// this file must define the BUILTIN macro to make use of this information.
+//
+//===----------------------------------------------------------------------===//
+
+// The format of this database matches clang/Basic/Builtins.def.
+
+// LoongArch BASE
+
+BUILTIN(__builtin_loongarch_cpucfg, "UiUi", "nc")
+BUILTIN(__builtin_loongarch_csrrd, "UiIUi", "nc")
+BUILTIN(__builtin_loongarch_dcsrrd, "ULiIULi", "nc")
+BUILTIN(__builtin_loongarch_csrwr, "UiUiIUi", "nc")
+BUILTIN(__builtin_loongarch_dcsrwr, "ULiULiIULi", "nc")
+BUILTIN(__builtin_loongarch_csrxchg, "UiUiUiIUi", "nc")
+BUILTIN(__builtin_loongarch_dcsrxchg, "ULiULiULiIULi", "nc")
+BUILTIN(__builtin_loongarch_iocsrrd_b, "UiUi", "nc")
+BUILTIN(__builtin_loongarch_iocsrrd_h, "UiUi", "nc")
+BUILTIN(__builtin_loongarch_iocsrrd_w, "UiUi", "nc")
+BUILTIN(__builtin_loongarch_iocsrrd_d, "ULiUi", "nc")
+BUILTIN(__builtin_loongarch_iocsrwr_b, "vUiUi", "nc")
+BUILTIN(__builtin_loongarch_iocsrwr_h, "vUiUi", "nc")
+BUILTIN(__builtin_loongarch_iocsrwr_w, "vUiUi", "nc")
+BUILTIN(__builtin_loongarch_iocsrwr_d, "vULiUi", "nc")
+BUILTIN(__builtin_loongarch_cacop, "viUii", "nc")
+BUILTIN(__builtin_loongarch_dcacop, "viULiLi", "nc")
+BUILTIN(__builtin_loongarch_crc_w_b_w, "iii", "nc")
+BUILTIN(__builtin_loongarch_crc_w_h_w, "iii", "nc")
+BUILTIN(__builtin_loongarch_crc_w_w_w, "iii", "nc")
+BUILTIN(__builtin_loongarch_crc_w_d_w, "iLii", "nc")
+BUILTIN(__builtin_loongarch_crcc_w_b_w, "iii", "nc")
+BUILTIN(__builtin_loongarch_crcc_w_h_w, "iii", "nc")
+BUILTIN(__builtin_loongarch_crcc_w_w_w, "iii", "nc")
+BUILTIN(__builtin_loongarch_crcc_w_d_w, "iLii", "nc")
+BUILTIN(__builtin_loongarch_tlbclr, "v", "nc")
+BUILTIN(__builtin_loongarch_tlbflush, "v", "nc")
+BUILTIN(__builtin_loongarch_tlbfill, "v", "nc")
+BUILTIN(__builtin_loongarch_tlbrd, "v", "nc")
+BUILTIN(__builtin_loongarch_tlbwr, "v", "nc")
+BUILTIN(__builtin_loongarch_tlbsrch, "v", "nc")
+BUILTIN(__builtin_loongarch_syscall, "vIULi", "nc")
+BUILTIN(__builtin_loongarch_break, "vIULi", "nc")
+BUILTIN(__builtin_loongarch_asrtle_d, "vLiLi", "nc")
+BUILTIN(__builtin_loongarch_asrtgt_d, "vLiLi", "nc")
+BUILTIN(__builtin_loongarch_dbar, "vIULi", "nc")
+BUILTIN(__builtin_loongarch_ibar, "vIULi", "nc")
+#undef BUILTIN
diff -uNr llvm-toolchain-14-14.0.6.orig/clang/include/clang/Basic/DiagnosticDriverKinds.td llvm-toolchain-14-14.0.6/clang/include/clang/Basic/DiagnosticDriverKinds.td
--- llvm-toolchain-14-14.0.6.orig/clang/include/clang/Basic/DiagnosticDriverKinds.td	2022-06-25 15:48:33.000000000 +0800
+++ llvm-toolchain-14-14.0.6/clang/include/clang/Basic/DiagnosticDriverKinds.td	2023-03-09 13:35:06.259619554 +0800
@@ -193,6 +193,8 @@
   "failing because %select{environment variable 'FORCE_CLANG_DIAGNOSTICS_CRASH' is set|'-gen-reproducer' is used}0">;
 def err_drv_invalid_mfloat_abi : Error<
   "invalid float ABI '%0'">;
+def err_drv_invalid_loongarch_mfpu : Error<
+  "invalid loongarch FPU value '%0'. Please specify FPU = 64,32 or none">;
 def err_drv_invalid_mtp : Error<
   "invalid thread pointer reading mode '%0'">;
 def err_drv_missing_arg_mtp : Error<
diff -uNr llvm-toolchain-14-14.0.6.orig/clang/include/clang/Basic/TargetBuiltins.h llvm-toolchain-14-14.0.6/clang/include/clang/Basic/TargetBuiltins.h
--- llvm-toolchain-14-14.0.6.orig/clang/include/clang/Basic/TargetBuiltins.h	2022-06-25 15:48:33.000000000 +0800
+++ llvm-toolchain-14-14.0.6/clang/include/clang/Basic/TargetBuiltins.h	2023-03-09 13:35:06.259619554 +0800
@@ -145,6 +145,16 @@
   };
   } // namespace RISCV
 
+  /// LoongArch builtins
+  namespace LoongArch {
+  enum {
+    LastTIBuiltin = clang::Builtin::FirstTSBuiltin-1,
+#define BUILTIN(ID, TYPE, ATTRS) BI##ID,
+#include "clang/Basic/BuiltinsLoongArch.def"
+    LastTSBuiltin
+  };
+  } // namespace LoongArch
+
   /// Flags to identify the types for overloaded Neon builtins.
   ///
   /// These must be kept in sync with the flags in utils/TableGen/NeonEmitter.h.
@@ -336,8 +346,8 @@
        PPC::LastTSBuiltin, NVPTX::LastTSBuiltin, AMDGPU::LastTSBuiltin,
        X86::LastTSBuiltin, VE::LastTSBuiltin, RISCV::LastTSBuiltin,
        Hexagon::LastTSBuiltin, Mips::LastTSBuiltin, XCore::LastTSBuiltin,
-       SystemZ::LastTSBuiltin, WebAssembly::LastTSBuiltin});
-
+       SystemZ::LastTSBuiltin, WebAssembly::LastTSBuiltin,
+       LoongArch::LastTSBuiltin});
 } // end namespace clang.
 
 #endif
diff -uNr llvm-toolchain-14-14.0.6.orig/clang/include/clang/Basic/TargetCXXABI.def llvm-toolchain-14-14.0.6/clang/include/clang/Basic/TargetCXXABI.def
--- llvm-toolchain-14-14.0.6.orig/clang/include/clang/Basic/TargetCXXABI.def	2022-01-23 08:26:54.000000000 +0800
+++ llvm-toolchain-14-14.0.6/clang/include/clang/Basic/TargetCXXABI.def	2023-03-09 13:35:06.259619554 +0800
@@ -88,6 +88,12 @@
 ///   - representation of member function pointers adjusted as in ARM.
 ITANIUM_CXXABI(GenericMIPS, "mips")
 
+/// The generic LoongArch ABI is a modified version of the Itanium ABI.
+///
+/// At the moment, only change from the generic ABI in this case is:
+///   - representation of member function pointers adjusted as in ARM.
+ITANIUM_CXXABI(GenericLoongArch, "loongarch")
+
 /// The WebAssembly ABI is a modified version of the Itanium ABI.
 ///
 /// The changes from the Itanium ABI are:
diff -uNr llvm-toolchain-14-14.0.6.orig/clang/include/clang/Basic/TargetCXXABI.h llvm-toolchain-14-14.0.6/clang/include/clang/Basic/TargetCXXABI.h
--- llvm-toolchain-14-14.0.6.orig/clang/include/clang/Basic/TargetCXXABI.h	2022-01-23 08:26:54.000000000 +0800
+++ llvm-toolchain-14-14.0.6/clang/include/clang/Basic/TargetCXXABI.h	2023-03-09 13:35:06.259619554 +0800
@@ -105,6 +105,9 @@
     case GenericMIPS:
       return T.isMIPS();
 
+    case GenericLoongArch:
+      return T.isLoongArch();
+
     case WebAssembly:
       return T.isWasm();
 
@@ -167,6 +170,7 @@
     case GenericARM:
     case GenericAArch64:
     case GenericMIPS:
+    case GenericLoongArch:
       // TODO: ARM-style pointers to member functions put the discriminator in
       //       the this adjustment, so they don't require functions to have any
       //       special alignment and could therefore also return false.
@@ -251,6 +255,7 @@
     case iOS:   // old iOS compilers did not follow this rule
     case Microsoft:
     case GenericMIPS:
+    case GenericLoongArch:
     case XL:
       return true;
     }
@@ -289,6 +294,7 @@
     case GenericARM:
     case iOS:
     case GenericMIPS:
+    case GenericLoongArch:
     case XL:
       return UseTailPaddingUnlessPOD03;
 
diff -uNr llvm-toolchain-14-14.0.6.orig/clang/include/clang/Driver/Options.td llvm-toolchain-14-14.0.6/clang/include/clang/Driver/Options.td
--- llvm-toolchain-14-14.0.6.orig/clang/include/clang/Driver/Options.td	2022-06-25 15:48:33.000000000 +0800
+++ llvm-toolchain-14-14.0.6/clang/include/clang/Driver/Options.td	2023-03-09 13:35:06.262952665 +0800
@@ -176,6 +176,8 @@
                            Group<m_Group>, Flags<[CoreOption]>, DocName<"X86">;
 def m_riscv_Features_Group : OptionGroup<"<riscv features group>">,
                              Group<m_Group>, DocName<"RISCV">;
+def m_loongarch_Features_Group : OptionGroup<"<loongarch features group>">,
+                                 Group<m_Group>, DocName<"LoongArch">;
 
 def m_libc_Group : OptionGroup<"<m libc group>">, Group<m_mips_Features_Group>,
                    Flags<[HelpHidden]>;
@@ -4248,6 +4250,14 @@
   def ffixed_d#i : Flag<["-"], "ffixed-d"#i>, Group<m_m68k_Features_Group>,
     HelpText<"Reserve the d"#i#" register (M68k only)">;
 
+// LoongArch features flags
+def mfix_loongson3_llsc : Flag<["-"], "mfix-loongson3-llsc">,
+    Group<m_loongarch_Features_Group>,
+    HelpText<"Workaround loongson3 llsc erratum (LoongArch only)">;
+def mno_fix_loongson3_llsc : Flag<["-"], "mno-fix-loongson3-llsc">,
+    Group<m_loongarch_Features_Group>,
+    HelpText<"Don't Workaround loongson3 llsc erratum (LoongArch only)">;
+
 // X86 feature flags
 def mx87 : Flag<["-"], "mx87">, Group<m_x86_Features_Group>;
 def mno_x87 : Flag<["-"], "mno-x87">, Group<m_x86_Features_Group>;
diff -uNr llvm-toolchain-14-14.0.6.orig/clang/include/clang/Sema/Sema.h llvm-toolchain-14-14.0.6/clang/include/clang/Sema/Sema.h
--- llvm-toolchain-14-14.0.6.orig/clang/include/clang/Sema/Sema.h	2022-06-25 15:48:33.000000000 +0800
+++ llvm-toolchain-14-14.0.6/clang/include/clang/Sema/Sema.h	2023-03-09 13:35:06.266285775 +0800
@@ -12727,6 +12727,9 @@
   bool CheckBPFBuiltinFunctionCall(unsigned BuiltinID, CallExpr *TheCall);
   bool CheckHexagonBuiltinFunctionCall(unsigned BuiltinID, CallExpr *TheCall);
   bool CheckHexagonBuiltinArgument(unsigned BuiltinID, CallExpr *TheCall);
+  bool CheckLoongArchBuiltinFunctionCall(const TargetInfo &TI,
+                                         unsigned BuiltinID,
+                                         CallExpr *TheCall);
   bool CheckMipsBuiltinFunctionCall(const TargetInfo &TI, unsigned BuiltinID,
                                     CallExpr *TheCall);
   bool CheckMipsBuiltinCpu(const TargetInfo &TI, unsigned BuiltinID,
diff -uNr llvm-toolchain-14-14.0.6.orig/clang/include/clang/module.modulemap llvm-toolchain-14-14.0.6/clang/include/clang/module.modulemap
--- llvm-toolchain-14-14.0.6.orig/clang/include/clang/module.modulemap	2022-06-25 15:48:33.000000000 +0800
+++ llvm-toolchain-14-14.0.6/clang/include/clang/module.modulemap	2023-03-09 13:35:06.266285775 +0800
@@ -42,6 +42,7 @@
   textual header "Basic/BuiltinsHexagon.def"
   textual header "Basic/BuiltinsHexagonDep.def"
   textual header "Basic/BuiltinsHexagonMapCustomDep.def"
+  textual header "Basic/BuiltinsLoongArch.def"
   textual header "Basic/BuiltinsMips.def"
   textual header "Basic/BuiltinsNEON.def"
   textual header "Basic/BuiltinsNVPTX.def"
diff -uNr llvm-toolchain-14-14.0.6.orig/clang/lib/AST/ASTContext.cpp llvm-toolchain-14-14.0.6/clang/lib/AST/ASTContext.cpp
--- llvm-toolchain-14-14.0.6.orig/clang/lib/AST/ASTContext.cpp	2022-06-25 15:48:33.000000000 +0800
+++ llvm-toolchain-14-14.0.6/clang/lib/AST/ASTContext.cpp	2023-03-09 13:35:06.269618886 +0800
@@ -901,6 +901,7 @@
   case TargetCXXABI::iOS:
   case TargetCXXABI::WatchOS:
   case TargetCXXABI::GenericAArch64:
+  case TargetCXXABI::GenericLoongArch:
   case TargetCXXABI::GenericMIPS:
   case TargetCXXABI::GenericItanium:
   case TargetCXXABI::WebAssembly:
@@ -11651,6 +11652,7 @@
   case TargetCXXABI::GenericAArch64:
   case TargetCXXABI::GenericItanium:
   case TargetCXXABI::GenericARM:
+  case TargetCXXABI::GenericLoongArch:
   case TargetCXXABI::GenericMIPS:
   case TargetCXXABI::iOS:
   case TargetCXXABI::WebAssembly:
diff -uNr llvm-toolchain-14-14.0.6.orig/clang/lib/Basic/CMakeLists.txt llvm-toolchain-14-14.0.6/clang/lib/Basic/CMakeLists.txt
--- llvm-toolchain-14-14.0.6.orig/clang/lib/Basic/CMakeLists.txt	2022-06-25 15:48:33.000000000 +0800
+++ llvm-toolchain-14-14.0.6/clang/lib/Basic/CMakeLists.txt	2023-03-09 13:35:06.269618886 +0800
@@ -79,6 +79,7 @@
   Targets/Lanai.cpp
   Targets/Le64.cpp
   Targets/M68k.cpp
+  Targets/LoongArch.cpp
   Targets/MSP430.cpp
   Targets/Mips.cpp
   Targets/NVPTX.cpp
diff -uNr llvm-toolchain-14-14.0.6.orig/clang/lib/Basic/Targets/LoongArch.cpp llvm-toolchain-14-14.0.6/clang/lib/Basic/Targets/LoongArch.cpp
--- llvm-toolchain-14-14.0.6.orig/clang/lib/Basic/Targets/LoongArch.cpp	1970-01-01 08:00:00.000000000 +0800
+++ llvm-toolchain-14-14.0.6/clang/lib/Basic/Targets/LoongArch.cpp	2023-03-09 13:35:06.272951997 +0800
@@ -0,0 +1,143 @@
+//===--- LoongArch.cpp - Implement LoongArch target feature support -----------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file implements LoongArch TargetInfo objects.
+//
+//===----------------------------------------------------------------------===//
+
+#include "LoongArch.h"
+#include "Targets.h"
+#include "clang/Basic/Diagnostic.h"
+#include "clang/Basic/MacroBuilder.h"
+#include "clang/Basic/TargetBuiltins.h"
+#include "llvm/ADT/StringSwitch.h"
+
+using namespace clang;
+using namespace clang::targets;
+
+const Builtin::Info LoongArchTargetInfo::BuiltinInfo[] = {
+#define BUILTIN(ID, TYPE, ATTRS)                                               \
+  {#ID, TYPE, ATTRS, nullptr, ALL_LANGUAGES, nullptr},
+#define LIBBUILTIN(ID, TYPE, ATTRS, HEADER)                                    \
+  {#ID, TYPE, ATTRS, HEADER, ALL_LANGUAGES, nullptr},
+#include "clang/Basic/BuiltinsLoongArch.def"
+};
+
+bool LoongArchTargetInfo::processorSupportsGPR64() const {
+  return llvm::StringSwitch<bool>(CPU)
+      .Case("la464", true)
+      .Default(false);
+  return false;
+}
+
+static constexpr llvm::StringLiteral ValidCPUNames[] = {
+    {"la464"}
+};
+
+bool LoongArchTargetInfo::isValidCPUName(StringRef Name) const {
+  return llvm::find(ValidCPUNames, Name) != std::end(ValidCPUNames);
+}
+
+void LoongArchTargetInfo::fillValidCPUList(
+    SmallVectorImpl<StringRef> &Values) const {
+  Values.append(std::begin(ValidCPUNames), std::end(ValidCPUNames));
+}
+
+void LoongArchTargetInfo::getTargetDefines(const LangOptions &Opts,
+                                      MacroBuilder &Builder) const {
+  Builder.defineMacro("__loongarch__");
+
+  if (ABI == "lp64d" || ABI == "lp64s" || ABI == "lp64f") {
+    Builder.defineMacro("__loongarch_lp64");
+    Builder.defineMacro("__loongarch64");
+    Builder.defineMacro("_ABILP64", "3");
+    Builder.defineMacro("_LOONGARCH_SIM", "_ABILP64");
+  } else
+    llvm_unreachable("Invalid ABI.");
+
+  Builder.defineMacro("__REGISTER_PREFIX__", "");
+
+  Builder.defineMacro("_LOONGARCH_SZPTR", Twine(getPointerWidth(0)));
+  Builder.defineMacro("_LOONGARCH_SZINT", Twine(getIntWidth()));
+  Builder.defineMacro("_LOONGARCH_SZLONG", Twine(getLongWidth()));
+
+  Builder.defineMacro("_LOONGARCH_TUNE", "\"" + CPU + "\"");
+  Builder.defineMacro("_LOONGARCH_TUNE_" + StringRef(CPU).upper());
+
+  Builder.defineMacro("_LOONGARCH_ARCH", "\"" + getTriple().getArchName() + "\"");
+  Builder.defineMacro("_LOONGARCH_ARCH_" + StringRef(getTriple().getArchName()).upper());
+
+  Builder.defineMacro("__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1");
+  Builder.defineMacro("__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2");
+  Builder.defineMacro("__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4");
+
+  // 32-bit loongarch processors don't have the necessary ll.d/sc.d instructions
+  // found in 64-bit processors.
+  if (ABI == "lp64d" || ABI == "lp64s" || ABI == "lp64f")
+    Builder.defineMacro("__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8");
+
+  // Bit-width of general purpose registers.
+  Builder.defineMacro("__loongarch_grlen", Twine(getRegisterWidth()));
+
+  // Bit-width of floating-point registers. The possible values for
+  // this macro are 0, 32 and 64. 0 if there is no FPU.
+  if (HasBasicD || HasBasicF)
+    Builder.defineMacro("__loongarch_frlen", HasBasicD ? "64" : "32");
+  else
+    Builder.defineMacro("__loongarch_frlen", "0");
+
+  // FIXME: Defined if floating-point/extended ABI type is single or double.
+  if (ABI == "lp64d" || ABI == "lp64f")
+    Builder.defineMacro("__loongarch_hard_float");
+
+  // FIXME: Defined if floating-point/extended ABI type is double.
+  if (ABI == "lp64d")
+    Builder.defineMacro("__loongarch_double_float");
+
+  // FIXME: Defined if floating-point/extended ABI type is single.
+  if (ABI == "lp64f")
+    Builder.defineMacro("__loongarch_single_float");
+
+  // FIXME: Defined if floating-point/extended ABI type is soft.
+  if (ABI == "lp64s")
+    Builder.defineMacro("__loongarch_soft_float");
+}
+
+bool LoongArchTargetInfo::hasFeature(StringRef Feature) const {
+  return llvm::StringSwitch<bool>(Feature)
+      .Case("d", HasBasicD)
+      .Case("f", HasBasicF)
+      .Default(false);
+}
+
+ArrayRef<Builtin::Info> LoongArchTargetInfo::getTargetBuiltins() const {
+  return llvm::makeArrayRef(BuiltinInfo, clang::LoongArch::LastTSBuiltin -
+                                             Builtin::FirstTSBuiltin);
+}
+
+bool LoongArchTargetInfo::validateTarget(DiagnosticsEngine &Diags) const {
+  // 64-bit ABI's require 64-bit CPU's.
+  if (!processorSupportsGPR64() &&
+      (ABI == "lp64d" || ABI == "lp64s" || ABI == "lp64f")) {
+    Diags.Report(diag::err_target_unsupported_abi) << ABI << CPU;
+    return false;
+  }
+
+  // FIXME: It's valid to use lp64d/lp64s/lp64f on a loongarch32 triple
+  // but the backend can't handle this yet. It's better to fail here than on the
+  // backend assertion.
+  if (getTriple().isLoongArch32() &&
+      (ABI == "lp64d" || ABI == "lp64s" || ABI == "lp64f")) {
+    Diags.Report(diag::err_target_unsupported_abi_for_triple)
+        << ABI << getTriple().str();
+    return false;
+  }
+
+  return true;
+}
diff -uNr llvm-toolchain-14-14.0.6.orig/clang/lib/Basic/Targets/LoongArch.h llvm-toolchain-14-14.0.6/clang/lib/Basic/Targets/LoongArch.h
--- llvm-toolchain-14-14.0.6.orig/clang/lib/Basic/Targets/LoongArch.h	1970-01-01 08:00:00.000000000 +0800
+++ llvm-toolchain-14-14.0.6/clang/lib/Basic/Targets/LoongArch.h	2023-03-09 13:35:06.272951997 +0800
@@ -0,0 +1,332 @@
+//===--- LoongArch.h - Declare LoongArch target feature support -----------*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file declares LoongArch TargetInfo objects.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_LIB_BASIC_TARGETS_LOONGARCH_H
+#define LLVM_CLANG_LIB_BASIC_TARGETS_LOONGARCH_H
+
+#include "clang/Basic/TargetInfo.h"
+#include "clang/Basic/TargetOptions.h"
+#include "llvm/ADT/Triple.h"
+#include "llvm/Support/Compiler.h"
+
+namespace clang {
+namespace targets {
+
+class LLVM_LIBRARY_VISIBILITY LoongArchTargetInfo : public TargetInfo {
+  void setDataLayout() {
+    StringRef Layout;
+
+    if (ABI == "ilp32d" || ABI == "ilp32f" || ABI == "ilp32s")
+      // TODO
+      llvm_unreachable("Unimplemented ABI");
+    else if (ABI == "lp64d" || ABI == "lp64s" || ABI == "lp64f")
+      Layout = "m:e-i8:8:32-i16:16:32-i64:64-n32:64-S128";
+    else
+      llvm_unreachable("Invalid ABI");
+
+    resetDataLayout(("e-" + Layout).str());
+  }
+
+  static const Builtin::Info BuiltinInfo[];
+  std::string CPU;
+  bool HasBasicF;
+  bool HasBasicD;
+
+protected:
+  std::string ABI;
+
+public:
+  LoongArchTargetInfo(const llvm::Triple &Triple, const TargetOptions &)
+      : TargetInfo(Triple), HasBasicF(false), HasBasicD(false) {
+    TheCXXABI.set(TargetCXXABI::GenericLoongArch);
+
+    if (Triple.isLoongArch32())
+      // TODO
+      llvm_unreachable("Unimplemented triple");
+    else
+      setABI("lp64d");
+
+    // Currently, CPU only supports 'la464' in LA.
+    if ( ABI == "lp64d")
+      CPU = "la464";
+  }
+
+  bool processorSupportsGPR64() const;
+
+  StringRef getABI() const override { return ABI; }
+
+  bool setABI(const std::string &Name) override {
+    if (Name == "ilp32d" || Name == "ilp32f" || Name == "ilp32s") {
+      // TODO
+      llvm_unreachable("Unimplemented ABI");
+    }
+
+    if (Name == "lp64d" || Name == "lp64s" || Name == "lp64f") {
+      setLP64ABITypes();
+      ABI = Name;
+      return true;
+    }
+    return false;
+  }
+
+  void setLP64ABITypes() {
+    LongDoubleWidth = LongDoubleAlign = 128;
+    LongDoubleFormat = &llvm::APFloat::IEEEquad();
+    MaxAtomicPromoteWidth = MaxAtomicInlineWidth = 64;
+    SuitableAlign = 128;
+    Int64Type = SignedLong;
+    IntMaxType = Int64Type;
+    LongWidth = LongAlign = 64;
+    PointerWidth = PointerAlign = 64;
+    PtrDiffType = SignedLong;
+    SizeType = UnsignedLong;
+  }
+
+  bool isValidCPUName(StringRef Name) const override;
+  void fillValidCPUList(SmallVectorImpl<StringRef> &Values) const override;
+
+  bool setCPU(const std::string &Name) override {
+    CPU = Name;
+    return isValidCPUName(Name);
+  }
+
+  const std::string &getCPU() const { return CPU; }
+  bool
+  initFeatureMap(llvm::StringMap<bool> &Features, DiagnosticsEngine &Diags,
+                 StringRef CPU,
+                 const std::vector<std::string> &FeaturesVec) const override {
+#if 0
+    if (CPU.empty())
+      CPU = getCPU();
+    Features[CPU] = true;
+#else
+//    if (CPU == "la464")
+//      Features["loongarch64"] = true;
+
+//FIXME: we need this?
+//    if (CPU == "la464")
+//      Features["64bit"] = true;
+#endif
+    return TargetInfo::initFeatureMap(Features, Diags, CPU, FeaturesVec);
+  }
+
+  void getTargetDefines(const LangOptions &Opts,
+                        MacroBuilder &Builder) const override;
+
+  ArrayRef<Builtin::Info> getTargetBuiltins() const override;
+
+  bool hasFeature(StringRef Feature) const override;
+
+  BuiltinVaListKind getBuiltinVaListKind() const override {
+    return TargetInfo::VoidPtrBuiltinVaList;
+  }
+
+  ArrayRef<const char *> getGCCRegNames() const override {
+    static const char *const GCCRegNames[] = {
+        // CPU register names
+        // Must match second column of GCCRegAliases
+        "$r0", "$r1", "$r2", "$r3", "$r4", "$r5", "$r6", "$r7", "$r8", "$r9", "$r10",
+        "$r11", "$r12", "$r13", "$r14", "$r15", "$r16", "$r17", "$r18", "$r19", "$r20",
+        "$r21", "$r22", "$r23", "$r24", "$r25", "$r26", "$r27", "$r28", "$r29", "$r30",
+        "$r31",
+        // Floating point register names
+        "$f0", "$f1", "$f2", "$f3", "$f4", "$f5", "$f6", "$f7", "$f8", "$f9",
+        "$f10", "$f11", "$f12", "$f13", "$f14", "$f15", "$f16", "$f17", "$f18",
+        "$f19", "$f20", "$f21", "$f22", "$f23", "$f24", "$f25", "$f26", "$f27",
+        "$f28", "$f29", "$f30", "$f31",
+        // condition register names
+        "$fcc0", "$fcc1", "$fcc2", "$fcc3", "$fcc4", "$fcc5", "$fcc6", "$fcc7"
+    };
+    return llvm::makeArrayRef(GCCRegNames);
+  }
+
+  bool validateAsmConstraint(const char *&Name,
+                             TargetInfo::ConstraintInfo &Info) const override {
+    switch (*Name) {
+    default:
+      return false;
+    case 'r': // CPU registers.
+    case 'f': // floating-point registers.
+      Info.setAllowsRegister();
+      return true;
+    case 'l': // Signed 16-bit constant
+    case 'I': // Signed 12-bit constant
+    case 'K': // Unsigned 12-bit constant
+    case 'J': // Integer 0
+    case 'G': // Floating-point 0
+      return true;
+    case 'm': // Memory address with 12-bit offset
+    case 'R': // An address that can be used in a non-macro load or store
+      Info.setAllowsMemory();
+      return true;
+    case 'Z':
+      if (Name[1] == 'C'        // Memory address with 16-bit and 4 bytes aligned offset
+          || Name[1] == 'B' ) { // Memory address with 0 offset
+        Info.setAllowsMemory();
+        Name++; // Skip over 'Z'.
+        return true;
+      }
+      return false;
+    }
+  }
+
+  std::string convertConstraint(const char *&Constraint) const override {
+    std::string R;
+    switch (*Constraint) {
+    case 'Z': // Two-character constraint; add "^" hint for later parsing.
+      if (Constraint[1] == 'C' || Constraint[1] == 'B') {
+        R = std::string("^") + std::string(Constraint, 2);
+        Constraint++;
+        return R;
+      }
+      break;
+    }
+    return TargetInfo::convertConstraint(Constraint);
+  }
+
+  const char *getClobbers() const override {
+#if 0
+    // In GCC, $1 is not widely used in generated code (it's used only in a few
+    // specific situations), so there is no real need for users to add it to
+    // the clobbers list if they want to use it in their inline assembly code.
+    //
+    // In LLVM, $1 is treated as a normal GPR and is always allocatable during
+    // code generation, so using it in inline assembly without adding it to the
+    // clobbers list can cause conflicts between the inline assembly code and
+    // the surrounding generated code.
+    //
+    // Another problem is that LLVM is allowed to choose $1 for inline assembly
+    // operands, which will conflict with the ".set at" assembler option (which
+    // we use only for inline assembly, in order to maintain compatibility with
+    // GCC) and will also conflict with the user's usage of $1.
+    //
+    // The easiest way to avoid these conflicts and keep $1 as an allocatable
+    // register for generated code is to automatically clobber $1 for all inline
+    // assembly code.
+    //
+    // FIXME: We should automatically clobber $1 only for inline assembly code
+    // which actually uses it. This would allow LLVM to use $1 for inline
+    // assembly operands if the user's assembly code doesn't use it.
+    return "~{$1}";
+#endif
+    return "";
+  }
+
+  bool handleTargetFeatures(std::vector<std::string> &Features,
+                            DiagnosticsEngine &Diags) override {
+    HasBasicF = false;
+    HasBasicD = false;
+
+    for (const auto &Feature : Features) {
+      if (Feature == "+f")
+        HasBasicF = true;
+      else if (Feature == "+d")
+        HasBasicD = true;
+    }
+
+    setDataLayout();
+
+    return true;
+  }
+
+  int getEHDataRegisterNumber(unsigned RegNo) const override {
+    if (RegNo == 0)
+      return 4;
+    if (RegNo == 1)
+      return 5;
+    return -1;
+  }
+
+  bool isCLZForZeroUndef() const override { return false; }
+
+  ArrayRef<TargetInfo::GCCRegAlias> getGCCRegAliases() const override {
+    static const TargetInfo::GCCRegAlias GCCRegAliases[] = {
+        {{"zero", "$zero", "r0", "$0"}, "$r0"},
+        {{"ra", "$ra", "r1", "$1"}, "$r1"},
+        {{"tp", "$tp", "r2", "$2"}, "$r2"},
+        {{"sp", "$sp", "r3", "$3"}, "$r3"},
+        {{"a0", "$a0", "r4", "$4", "v0"}, "$r4"},
+        {{"a1", "$a1", "r5", "$5", "v1"}, "$r5"},
+        {{"a2", "$a2", "r6", "$6"}, "$r6"},
+        {{"a3", "$a3", "r7", "$7"}, "$r7"},
+        {{"a4", "$a4", "r8", "$8"}, "$r8"},
+        {{"a5", "$a5", "r9", "$9"}, "$r9"},
+        {{"a6", "$a6", "r10", "$10"}, "$r10"},
+        {{"a7", "$a7", "r11", "$11"}, "$r11"},
+        {{"t0", "$t0", "r12", "$12"}, "$r12"},
+        {{"t1", "$t1", "r13", "$13"}, "$r13"},
+        {{"t2", "$t2", "r14", "$14"}, "$r14"},
+        {{"t3", "$t3", "r15", "$15"}, "$r15"},
+        {{"t4", "$t4", "r16", "$16"}, "$r16"},
+        {{"t5", "$t5", "r17", "$17"}, "$r17"},
+        {{"t6", "$t6", "r18", "$18"}, "$r18"},
+        {{"t7", "$t7", "r19", "$19"}, "$r19"},
+        {{"t8", "$t8", "r20", "$20"}, "$r20"},
+        //{{"x", "$x", "r21", "$21"}, "$r21"},
+        {{"fp", "$fp", "r22", "$22"}, "$r22"},
+        {{"s0", "$s0", "r23", "$23"}, "$r23"},
+        {{"s1", "$s1", "r24", "$24"}, "$r24"},
+        {{"s2", "$s2", "r25", "$25"}, "$r25"},
+        {{"s3", "$s3", "r26", "$26"}, "$r26"},
+        {{"s4", "$s4", "r27", "$27"}, "$r27"},
+        {{"s5", "$s5", "r28", "$28"}, "$r28"},
+        {{"s6", "$s6", "r29", "$29"}, "$r29"},
+        {{"s7", "$s7", "r30", "$30"}, "$r30"},
+        {{"s8", "$s8", "r31", "$31"}, "$r31"},
+        {{"fa0", "$fa0", "f0"}, "$f0"},
+        {{"fa1", "$fa1", "f1"}, "$f1"},
+        {{"fa2", "$fa2", "f2"}, "$f2"},
+        {{"fa3", "$fa3", "f3"}, "$f3"},
+        {{"fa4", "$fa4", "f4"}, "$f4"},
+        {{"fa5", "$fa5", "f5"}, "$f5"},
+        {{"fa6", "$fa6", "f6"}, "$f6"},
+        {{"fa7", "$fa7", "f7"}, "$f7"},
+        {{"ft0", "$ft0", "f8"}, "$f8"},
+        {{"ft1", "$ft1", "f9"}, "$f9"},
+        {{"ft2", "$ft2", "f10"}, "$f10"},
+        {{"ft3", "$ft3", "f11"}, "$f11"},
+        {{"ft4", "$ft4", "f12"}, "$f12"},
+        {{"ft5", "$ft5", "f13"}, "$f13"},
+        {{"ft6", "$ft6", "f14"}, "$f14"},
+        {{"ft7", "$ft7", "f15"}, "$f15"},
+        {{"ft8", "$ft8", "f16"}, "$f16"},
+        {{"ft9", "$ft9", "f17"}, "$f17"},
+        {{"ft10", "$ft10", "f18"}, "$f18"},
+        {{"ft11", "$ft11", "f19"}, "$f19"},
+        {{"ft12", "$ft12", "f20"}, "$f20"},
+        {{"ft13", "$ft13", "f21"}, "$f21"},
+        {{"ft14", "$ft14", "f22"}, "$f22"},
+        {{"ft15", "$ft15", "f23"}, "$f23"},
+        {{"fs0", "$fs0", "f24"}, "$f24"},
+        {{"fs1", "$fs1", "f25"}, "$f25"},
+        {{"fs2", "$fs2", "f26"}, "$f26"},
+        {{"fs3", "$fs3", "f27"}, "$f27"},
+        {{"fs4", "$fs4", "f28"}, "$f28"},
+        {{"fs5", "$fs5", "f29"}, "$f29"},
+        {{"fs6", "$fs6", "f30"}, "$f30"},
+        {{"fs7", "$fs7", "f31"}, "$f31"},
+    };
+    return llvm::makeArrayRef(GCCRegAliases);
+  }
+
+  bool hasInt128Type() const override {
+    return (ABI == "lp64d" || ABI == "lp64s" || ABI == "lp64f") ||
+           getTargetOpts().ForceEnableInt128;
+  }
+
+  bool validateTarget(DiagnosticsEngine &Diags) const override;
+};
+} // namespace targets
+} // namespace clang
+
+#endif // LLVM_CLANG_LIB_BASIC_TARGETS_LOONGARCH_H
diff -uNr llvm-toolchain-14-14.0.6.orig/clang/lib/Basic/Targets.cpp llvm-toolchain-14-14.0.6/clang/lib/Basic/Targets.cpp
--- llvm-toolchain-14-14.0.6.orig/clang/lib/Basic/Targets.cpp	2022-06-25 15:48:33.000000000 +0800
+++ llvm-toolchain-14-14.0.6/clang/lib/Basic/Targets.cpp	2023-03-09 13:35:06.272951997 +0800
@@ -23,6 +23,7 @@
 #include "Targets/Lanai.h"
 #include "Targets/Le64.h"
 #include "Targets/M68k.h"
+#include "Targets/LoongArch.h"
 #include "Targets/MSP430.h"
 #include "Targets/Mips.h"
 #include "Targets/NVPTX.h"
@@ -325,6 +326,25 @@
   case llvm::Triple::le64:
     return new Le64TargetInfo(Triple, Opts);
 
+#if 0
+  //TODO: support it in future
+  case llvm::Triple::loongarch32:
+    switch (os) {
+    case llvm::Triple::Linux:
+      return new LinuxTargetInfo<LoongArchTargetInfo>(Triple, Opts);
+    default:
+      return new LoongArchTargetInfo(Triple, Opts);
+    }
+#endif
+
+  case llvm::Triple::loongarch64:
+    switch (os) {
+    case llvm::Triple::Linux:
+      return new LinuxTargetInfo<LoongArchTargetInfo>(Triple, Opts);
+    default:
+      return new LoongArchTargetInfo(Triple, Opts);
+    }
+
   case llvm::Triple::ppc:
     if (Triple.isOSDarwin())
       return new DarwinPPC32TargetInfo(Triple, Opts);
diff -uNr llvm-toolchain-14-14.0.6.orig/clang/lib/CodeGen/CodeGenModule.cpp llvm-toolchain-14-14.0.6/clang/lib/CodeGen/CodeGenModule.cpp
--- llvm-toolchain-14-14.0.6.orig/clang/lib/CodeGen/CodeGenModule.cpp	2022-06-25 15:48:33.000000000 +0800
+++ llvm-toolchain-14-14.0.6/clang/lib/CodeGen/CodeGenModule.cpp	2023-03-09 13:35:06.272951997 +0800
@@ -82,6 +82,7 @@
   case TargetCXXABI::GenericARM:
   case TargetCXXABI::iOS:
   case TargetCXXABI::WatchOS:
+  case TargetCXXABI::GenericLoongArch:
   case TargetCXXABI::GenericMIPS:
   case TargetCXXABI::GenericItanium:
   case TargetCXXABI::WebAssembly:
diff -uNr llvm-toolchain-14-14.0.6.orig/clang/lib/CodeGen/ItaniumCXXABI.cpp llvm-toolchain-14-14.0.6/clang/lib/CodeGen/ItaniumCXXABI.cpp
--- llvm-toolchain-14-14.0.6.orig/clang/lib/CodeGen/ItaniumCXXABI.cpp	2022-06-25 15:48:33.000000000 +0800
+++ llvm-toolchain-14-14.0.6/clang/lib/CodeGen/ItaniumCXXABI.cpp	2023-03-09 13:35:06.276285108 +0800
@@ -533,6 +533,9 @@
     return new ItaniumCXXABI(CGM, /*UseARMMethodPtrABI=*/true,
                              /*UseARMGuardVarABI=*/true);
 
+  case TargetCXXABI::GenericLoongArch:
+    return new ItaniumCXXABI(CGM, /*UseARMMethodPtrABI=*/true);
+
   case TargetCXXABI::GenericMIPS:
     return new ItaniumCXXABI(CGM, /*UseARMMethodPtrABI=*/true);
 
diff -uNr llvm-toolchain-14-14.0.6.orig/clang/lib/CodeGen/TargetInfo.cpp llvm-toolchain-14-14.0.6/clang/lib/CodeGen/TargetInfo.cpp
--- llvm-toolchain-14-14.0.6.orig/clang/lib/CodeGen/TargetInfo.cpp	2022-06-25 15:48:33.000000000 +0800
+++ llvm-toolchain-14-14.0.6/clang/lib/CodeGen/TargetInfo.cpp	2023-03-09 13:35:06.279618219 +0800
@@ -7806,6 +7806,543 @@
 }
 
 //===----------------------------------------------------------------------===//
+// LoongArch ABI Implementation
+//===----------------------------------------------------------------------===//
+
+namespace {
+class LoongArchABIInfo : public DefaultABIInfo {
+private:
+  // Size of the integer ('r') registers in bits.
+  unsigned GRLen;
+  // Size of the floating point ('f') registers in bits. Note that the target
+  // ISA might have a wider FRLen than the selected ABI.
+  unsigned FRLen;
+  static const int NumArgGPRs = 8;
+  static const int NumArgFPRs = 8;
+  bool detectFPCCEligibleStructHelper(QualType Ty, CharUnits CurOff,
+                                      llvm::Type *&Field1Ty,
+                                      CharUnits &Field1Off,
+                                      llvm::Type *&Field2Ty,
+                                      CharUnits &Field2Off) const;
+
+public:
+  LoongArchABIInfo(CodeGen::CodeGenTypes &CGT, unsigned GRLen, unsigned FRLen)
+      : DefaultABIInfo(CGT), GRLen(GRLen), FRLen(FRLen) {}
+
+  // DefaultABIInfo's classifyReturnType and classifyArgumentType are
+  // non-virtual, but computeInfo is virtual, so we overload it.
+  void computeInfo(CGFunctionInfo &FI) const override;
+
+  ABIArgInfo classifyArgumentType(QualType Ty, bool IsFixed, int &ArgGPRsLeft,
+                                  int &ArgFPRsLeft) const;
+  ABIArgInfo classifyReturnType(QualType RetTy) const;
+
+  uint64_t MinABIStackAlignInBytes = 8;
+  uint64_t StackAlignInBytes = 16;
+  llvm::Type* HandleAggregates(QualType Ty, uint64_t TySize) const;
+  llvm::Type* getPaddingType(uint64_t Align, uint64_t Offset) const;
+  void CoerceToIntArgs(uint64_t TySize,
+                       SmallVectorImpl<llvm::Type *> &ArgList) const;
+
+  Address EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,
+                    QualType Ty) const override;
+
+  ABIArgInfo extendType(QualType Ty) const;
+
+  bool detectFPCCEligibleStruct(QualType Ty, llvm::Type *&Field1Ty,
+                                CharUnits &Field1Off, llvm::Type *&Field2Ty,
+                                CharUnits &Field2Off, int &NeededArgGPRs,
+                                int &NeededArgFPRs) const;
+  ABIArgInfo coerceAndExpandFPCCEligibleStruct(llvm::Type *Field1Ty,
+                                               CharUnits Field1Off,
+                                               llvm::Type *Field2Ty,
+                                               CharUnits Field2Off) const;
+};
+} // end anonymous namespace
+
+void LoongArchABIInfo::computeInfo(CGFunctionInfo &FI) const {
+  QualType RetTy = FI.getReturnType();
+  if (!getCXXABI().classifyReturnType(FI))
+    FI.getReturnInfo() = classifyReturnType(RetTy);
+
+  // IsRetIndirect is true if classifyArgumentType indicated the value should
+  // be passed indirect or if the type size is greater than 2*grlen.
+  bool IsRetIndirect = FI.getReturnInfo().getKind() == ABIArgInfo::Indirect ||
+                       getContext().getTypeSize(RetTy) > (2 * GRLen);
+
+  // We must track the number of GPRs used in order to conform to the LoongArch
+  // ABI, as integer scalars passed in registers should have signext/zeroext
+  // when promoted, but are anyext if passed on the stack. As GPR usage is
+  // different for variadic arguments, we must also track whether we are
+  // examining a vararg or not.
+  int ArgGPRsLeft = IsRetIndirect ? NumArgGPRs - 1 : NumArgGPRs;
+  int ArgFPRsLeft = FRLen ? NumArgFPRs : 0;
+  int NumFixedArgs = FI.getNumRequiredArgs();
+
+  int ArgNum = 0;
+  for (auto &ArgInfo : FI.arguments()) {
+    bool IsFixed = ArgNum < NumFixedArgs;
+    ArgInfo.info =
+        classifyArgumentType(ArgInfo.type, IsFixed, ArgGPRsLeft, ArgFPRsLeft);
+    ArgNum++;
+  }
+}
+
+// Returns true if the struct is a potential candidate for the floating point
+// calling convention. If this function returns true, the caller is
+// responsible for checking that if there is only a single field then that
+// field is a float.
+bool LoongArchABIInfo::detectFPCCEligibleStructHelper(QualType Ty, CharUnits CurOff,
+                                                  llvm::Type *&Field1Ty,
+                                                  CharUnits &Field1Off,
+                                                  llvm::Type *&Field2Ty,
+                                                  CharUnits &Field2Off) const {
+  bool IsInt = Ty->isIntegralOrEnumerationType();
+  bool IsFloat = Ty->isRealFloatingType();
+
+  if (IsInt || IsFloat) {
+    uint64_t Size = getContext().getTypeSize(Ty);
+    if (IsInt && Size > GRLen)
+      return false;
+    // Can't be eligible if larger than the FP registers. Half precision isn't
+    // currently supported on LoongArch and the ABI hasn't been confirmed, so
+    // default to the integer ABI in that case.
+    if (IsFloat && (Size > FRLen || Size < 32))
+      return false;
+    // Can't be eligible if an integer type was already found (int+int pairs
+    // are not eligible).
+    if (IsInt && Field1Ty && Field1Ty->isIntegerTy())
+      return false;
+    if (!Field1Ty) {
+      Field1Ty = CGT.ConvertType(Ty);
+      Field1Off = CurOff;
+      return true;
+    }
+    if (!Field2Ty) {
+      Field2Ty = CGT.ConvertType(Ty);
+      Field2Off = CurOff;
+      return true;
+    }
+    return false;
+  }
+
+  if (auto CTy = Ty->getAs<ComplexType>()) {
+    if (Field1Ty)
+      return false;
+    QualType EltTy = CTy->getElementType();
+    if (getContext().getTypeSize(EltTy) > FRLen)
+      return false;
+    Field1Ty = CGT.ConvertType(EltTy);
+    Field1Off = CurOff;
+    assert(CurOff.isZero() && "Unexpected offset for first field");
+    Field2Ty = Field1Ty;
+    Field2Off = Field1Off + getContext().getTypeSizeInChars(EltTy);
+    return true;
+  }
+
+  if (const ConstantArrayType *ATy = getContext().getAsConstantArrayType(Ty)) {
+    uint64_t ArraySize = ATy->getSize().getZExtValue();
+    QualType EltTy = ATy->getElementType();
+    CharUnits EltSize = getContext().getTypeSizeInChars(EltTy);
+    for (uint64_t i = 0; i < ArraySize; ++i) {
+      bool Ret = detectFPCCEligibleStructHelper(EltTy, CurOff, Field1Ty,
+                                                Field1Off, Field2Ty, Field2Off);
+      if (!Ret)
+        return false;
+      CurOff += EltSize;
+    }
+    return true;
+  }
+
+  if (const auto *RTy = Ty->getAs<RecordType>()) {
+    // Structures with either a non-trivial destructor or a non-trivial
+    // copy constructor are not eligible for the FP calling convention.
+    if (getRecordArgABI(Ty, CGT.getCXXABI()))
+      return false;
+    if (isEmptyRecord(getContext(), Ty, true))
+      return true;
+    const RecordDecl *RD = RTy->getDecl();
+    // Unions aren't eligible unless they're empty (which is caught above).
+    if (RD->isUnion())
+      return false;
+    int ZeroWidthBitFieldCount = 0;
+    for (const FieldDecl *FD : RD->fields()) {
+      const ASTRecordLayout &Layout = getContext().getASTRecordLayout(RD);
+      uint64_t FieldOffInBits = Layout.getFieldOffset(FD->getFieldIndex());
+      QualType QTy = FD->getType();
+      if (FD->isBitField()) {
+        unsigned BitWidth = FD->getBitWidthValue(getContext());
+        // Allow a bitfield with a type greater than GRLen as long as the
+        // bitwidth is GRLen or less.
+        if (getContext().getTypeSize(QTy) > GRLen && BitWidth <= GRLen)
+          QTy = getContext().getIntTypeForBitwidth(GRLen, false);
+        if (BitWidth == 0) {
+          ZeroWidthBitFieldCount++;
+          continue;
+        }
+      }
+
+      bool Ret = detectFPCCEligibleStructHelper(
+          QTy, CurOff + getContext().toCharUnitsFromBits(FieldOffInBits),
+          Field1Ty, Field1Off, Field2Ty, Field2Off);
+      if (!Ret)
+        return false;
+
+      // As a quirk of the ABI, zero-width bitfields aren't ignored for fp+fp
+      // or int+fp structs, but are ignored for a struct with an fp field and
+      // any number of zero-width bitfields.
+      if (Field2Ty && ZeroWidthBitFieldCount > 0)
+        return false;
+    }
+    return Field1Ty != nullptr;
+  }
+
+  return false;
+}
+
+// Determine if a struct is eligible for passing according to the floating
+// point calling convention (i.e., when flattened it contains a single fp
+// value, fp+fp, or int+fp of appropriate size). If so, NeededArgFPRs and
+// NeededArgGPRs are incremented appropriately.
+bool LoongArchABIInfo::detectFPCCEligibleStruct(QualType Ty, llvm::Type *&Field1Ty,
+                                            CharUnits &Field1Off,
+                                            llvm::Type *&Field2Ty,
+                                            CharUnits &Field2Off,
+                                            int &NeededArgGPRs,
+                                            int &NeededArgFPRs) const {
+  Field1Ty = nullptr;
+  Field2Ty = nullptr;
+  NeededArgGPRs = 0;
+  NeededArgFPRs = 0;
+  bool IsCandidate = detectFPCCEligibleStructHelper(
+      Ty, CharUnits::Zero(), Field1Ty, Field1Off, Field2Ty, Field2Off);
+  // Not really a candidate if we have a single int but no float.
+  if (Field1Ty && !Field2Ty && !Field1Ty->isFloatingPointTy())
+    return IsCandidate = false;
+  if (!IsCandidate)
+    return false;
+  if (Field1Ty && Field1Ty->isFloatingPointTy())
+    NeededArgFPRs++;
+  else if (Field1Ty)
+    NeededArgGPRs++;
+  if (Field2Ty && Field2Ty->isFloatingPointTy())
+    NeededArgFPRs++;
+  else if (Field2Ty)
+    NeededArgGPRs++;
+  return IsCandidate;
+}
+
+// Call getCoerceAndExpand for the two-element flattened struct described by
+// Field1Ty, Field1Off, Field2Ty, Field2Off. This method will create an
+// appropriate coerceToType and unpaddedCoerceToType.
+ABIArgInfo LoongArchABIInfo::coerceAndExpandFPCCEligibleStruct(
+    llvm::Type *Field1Ty, CharUnits Field1Off, llvm::Type *Field2Ty,
+    CharUnits Field2Off) const {
+  SmallVector<llvm::Type *, 3> CoerceElts;
+  SmallVector<llvm::Type *, 2> UnpaddedCoerceElts;
+  if (!Field1Off.isZero())
+    CoerceElts.push_back(llvm::ArrayType::get(
+        llvm::Type::getInt8Ty(getVMContext()), Field1Off.getQuantity()));
+
+  CoerceElts.push_back(Field1Ty);
+  UnpaddedCoerceElts.push_back(Field1Ty);
+
+  if (!Field2Ty) {
+    return ABIArgInfo::getCoerceAndExpand(
+        llvm::StructType::get(getVMContext(), CoerceElts, !Field1Off.isZero()),
+        UnpaddedCoerceElts[0]);
+  }
+
+  CharUnits Field2Align =
+      CharUnits::fromQuantity(getDataLayout().getABITypeAlignment(Field2Ty));
+  CharUnits Field1Size =
+      CharUnits::fromQuantity(getDataLayout().getTypeStoreSize(Field1Ty));
+  CharUnits Field2OffNoPadNoPack = Field1Size.alignTo(Field2Align);
+
+  CharUnits Padding = CharUnits::Zero();
+  if (Field2Off > Field2OffNoPadNoPack)
+    Padding = Field2Off - Field2OffNoPadNoPack;
+  else if (Field2Off != Field2Align && Field2Off > Field1Size)
+    Padding = Field2Off - Field1Size;
+
+  bool IsPacked = !Field2Off.isMultipleOf(Field2Align);
+
+  if (!Padding.isZero())
+    CoerceElts.push_back(llvm::ArrayType::get(
+        llvm::Type::getInt8Ty(getVMContext()), Padding.getQuantity()));
+
+  CoerceElts.push_back(Field2Ty);
+  UnpaddedCoerceElts.push_back(Field2Ty);
+
+  auto CoerceToType =
+      llvm::StructType::get(getVMContext(), CoerceElts, IsPacked);
+  auto UnpaddedCoerceToType =
+      llvm::StructType::get(getVMContext(), UnpaddedCoerceElts, IsPacked);
+
+  return ABIArgInfo::getCoerceAndExpand(CoerceToType, UnpaddedCoerceToType);
+}
+
+void LoongArchABIInfo::CoerceToIntArgs(
+    uint64_t TySize, SmallVectorImpl<llvm::Type *> &ArgList) const {
+  llvm::IntegerType *IntTy =
+    llvm::IntegerType::get(getVMContext(), MinABIStackAlignInBytes * 8);
+
+  // Add (TySize / MinABIStackAlignInBytes) args of IntTy.
+  for (unsigned N = TySize / (MinABIStackAlignInBytes * 8); N; --N)
+    ArgList.push_back(IntTy);
+
+  // If necessary, add one more integer type to ArgList.
+  unsigned R = TySize % (MinABIStackAlignInBytes * 8);
+
+  if (R)
+    ArgList.push_back(llvm::IntegerType::get(getVMContext(), R));
+}
+
+llvm::Type*  LoongArchABIInfo::HandleAggregates(QualType Ty, uint64_t TySize) const {
+  SmallVector<llvm::Type*, 8> ArgList, IntArgList;
+
+  if (Ty->isComplexType())
+    return CGT.ConvertType(Ty);
+
+  const RecordType *RT = Ty->getAs<RecordType>();
+
+  // Unions/vectors are passed in integer registers.
+  if (!RT || !RT->isStructureOrClassType()) {
+    CoerceToIntArgs(TySize, ArgList);
+    return llvm::StructType::get(getVMContext(), ArgList);
+  }
+
+  const RecordDecl *RD = RT->getDecl();
+  const ASTRecordLayout &Layout = getContext().getASTRecordLayout(RD);
+  assert(!(TySize % 8) && "Size of structure must be multiple of 8.");
+
+  uint64_t LastOffset = 0;
+  unsigned idx = 0;
+  llvm::IntegerType *I64 = llvm::IntegerType::get(getVMContext(), 64);
+
+  // Iterate over fields in the struct/class and check if there are any aligned
+  // double fields.
+  for (RecordDecl::field_iterator i = RD->field_begin(), e = RD->field_end();
+       i != e; ++i, ++idx) {
+    const QualType Ty = i->getType();
+    const BuiltinType *BT = Ty->getAs<BuiltinType>();
+
+    if (!BT || BT->getKind() != BuiltinType::Double)
+      continue;
+
+    uint64_t Offset = Layout.getFieldOffset(idx);
+    if (Offset % 64) // Ignore doubles that are not aligned.
+      continue;
+
+    // Add ((Offset - LastOffset) / 64) args of type i64.
+    for (unsigned j = (Offset - LastOffset) / 64; j > 0; --j)
+      ArgList.push_back(I64);
+
+    // Add double type.
+    ArgList.push_back(llvm::Type::getDoubleTy(getVMContext()));
+    LastOffset = Offset + 64;
+  }
+
+  CoerceToIntArgs(TySize - LastOffset, IntArgList);
+  ArgList.append(IntArgList.begin(), IntArgList.end());
+
+  return llvm::StructType::get(getVMContext(), ArgList);
+}
+
+llvm::Type * LoongArchABIInfo::getPaddingType(uint64_t OrigOffset,
+                                        uint64_t Offset) const {
+  if (OrigOffset + MinABIStackAlignInBytes > Offset)
+    return nullptr;
+
+  return llvm::IntegerType::get(getVMContext(), (Offset - OrigOffset) * 8);
+}
+
+ABIArgInfo LoongArchABIInfo::classifyArgumentType(QualType Ty, bool IsFixed,
+                                              int &ArgGPRsLeft,
+                                              int &ArgFPRsLeft) const {
+  assert(ArgGPRsLeft <= NumArgGPRs && "Arg GPR tracking underflow");
+  Ty = useFirstFieldIfTransparentUnion(Ty);
+
+  // Structures with either a non-trivial destructor or a non-trivial
+  // copy constructor are always passed indirectly.
+  if (CGCXXABI::RecordArgABI RAA = getRecordArgABI(Ty, getCXXABI())) {
+    if (ArgGPRsLeft)
+      ArgGPRsLeft -= 1;
+    return getNaturalAlignIndirect(Ty, /*ByVal=*/RAA ==
+                                           CGCXXABI::RAA_DirectInMemory);
+  }
+
+  // Ignore empty structs/unions.
+  if (isEmptyRecord(getContext(), Ty, true))
+    return ABIArgInfo::getIgnore();
+
+  uint64_t Size = getContext().getTypeSize(Ty);
+
+  // Pass floating point values via FPRs if possible.
+  if (IsFixed && Ty->isFloatingType() && FRLen >= Size && ArgFPRsLeft) {
+    ArgFPRsLeft--;
+    return ABIArgInfo::getDirect();
+  }
+
+  // Complex types for the hard float ABI must be passed direct rather than
+  // using CoerceAndExpand.
+  if (IsFixed && Ty->isComplexType() && FRLen && ArgFPRsLeft >= 2) {
+    QualType EltTy = Ty->getAs<ComplexType>()->getElementType();
+    if (getContext().getTypeSize(EltTy) <= FRLen) {
+      ArgFPRsLeft -= 2;
+      return ABIArgInfo::getDirect();
+    }
+  }
+
+  if (IsFixed && FRLen && Ty->isStructureOrClassType()) {
+    llvm::Type *Field1Ty = nullptr;
+    llvm::Type *Field2Ty = nullptr;
+    CharUnits Field1Off = CharUnits::Zero();
+    CharUnits Field2Off = CharUnits::Zero();
+    int NeededArgGPRs;
+    int NeededArgFPRs;
+    bool IsCandidate =
+        detectFPCCEligibleStruct(Ty, Field1Ty, Field1Off, Field2Ty, Field2Off,
+                                 NeededArgGPRs, NeededArgFPRs);
+    if (Ty->isStructureOrClassType() && isAggregateTypeForABI(Ty))
+      IsCandidate = false;
+    if (IsCandidate && NeededArgGPRs <= ArgGPRsLeft &&
+        NeededArgFPRs <= ArgFPRsLeft) {
+      ArgGPRsLeft -= NeededArgGPRs;
+      ArgFPRsLeft -= NeededArgFPRs;
+      return coerceAndExpandFPCCEligibleStruct(Field1Ty, Field1Off, Field2Ty,
+                                               Field2Off);
+    }
+  } else if (Ty->isStructureOrClassType() && Size == 128 &&
+             isAggregateTypeForABI(Ty)) {
+    uint64_t Offset = 8;
+    uint64_t OrigOffset = Offset;
+    uint64_t TySize = getContext().getTypeSize(Ty);
+    uint64_t Align = getContext().getTypeAlign(Ty) / 8;
+
+    Align = std::min(std::max(Align, (uint64_t)MinABIStackAlignInBytes),
+                     (uint64_t)StackAlignInBytes);
+    unsigned CurrOffset = llvm::alignTo(Offset, Align);
+    Offset = CurrOffset + llvm::alignTo(TySize, Align * 8) / 8;
+
+    ABIArgInfo ArgInfo =
+        ABIArgInfo::getDirect(HandleAggregates(Ty, TySize), 0,
+                              getPaddingType(OrigOffset, CurrOffset));
+    ArgInfo.setInReg(true);
+    return ArgInfo;
+  }
+
+  uint64_t NeededAlign = getContext().getTypeAlign(Ty);
+  bool MustUseStack = false;
+  // Determine the number of GPRs needed to pass the current argument
+  // according to the ABI. 2*GRLen-aligned varargs are passed in "aligned"
+  // register pairs, so may consume 3 registers.
+  int NeededArgGPRs = 1;
+  if (!IsFixed && NeededAlign == 2 * GRLen)
+    NeededArgGPRs = 2 + (ArgGPRsLeft % 2);
+  else if (Size > GRLen && Size <= 2 * GRLen)
+    NeededArgGPRs = 2;
+
+  if (NeededArgGPRs > ArgGPRsLeft) {
+    MustUseStack = true;
+    NeededArgGPRs = ArgGPRsLeft;
+  }
+
+  ArgGPRsLeft -= NeededArgGPRs;
+
+  if (!isAggregateTypeForABI(Ty) && !Ty->isVectorType()) {
+    // Treat an enum type as its underlying type.
+    if (const EnumType *EnumTy = Ty->getAs<EnumType>())
+      Ty = EnumTy->getDecl()->getIntegerType();
+
+    // All integral types are promoted to GRLen width, unless passed on the
+    // stack.
+    if (Size < GRLen && Ty->isIntegralOrEnumerationType() && !MustUseStack) {
+      return extendType(Ty);
+    }
+
+    return ABIArgInfo::getDirect();
+  }
+
+  // Aggregates which are <= 2*GRLen will be passed in registers if possible,
+  // so coerce to integers.
+  if (Size <= 2 * GRLen) {
+    unsigned Alignment = getContext().getTypeAlign(Ty);
+
+    // Use a single GRLen int if possible, 2*GRLen if 2*GRLen alignment is
+    // required, and a 2-element GRLen array if only GRLen alignment is required.
+    if (Size <= GRLen) {
+      return ABIArgInfo::getDirect(
+          llvm::IntegerType::get(getVMContext(), GRLen));
+    } else if (Alignment == 2 * GRLen) {
+      return ABIArgInfo::getDirect(
+          llvm::IntegerType::get(getVMContext(), 2 * GRLen));
+    } else {
+      return ABIArgInfo::getDirect(llvm::ArrayType::get(
+          llvm::IntegerType::get(getVMContext(), GRLen), 2));
+    }
+  }
+  return getNaturalAlignIndirect(Ty, /*ByVal=*/false);
+}
+
+ABIArgInfo LoongArchABIInfo::classifyReturnType(QualType RetTy) const {
+  if (RetTy->isVoidType())
+    return ABIArgInfo::getIgnore();
+
+  int ArgGPRsLeft = 2;
+  int ArgFPRsLeft = FRLen ? 2 : 0;
+
+  // The rules for return and argument types are the same, so defer to
+  // classifyArgumentType.
+  return classifyArgumentType(RetTy, /*IsFixed=*/true, ArgGPRsLeft,
+                              ArgFPRsLeft);
+}
+
+Address LoongArchABIInfo::EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,
+                                    QualType Ty) const {
+  CharUnits SlotSize = CharUnits::fromQuantity(GRLen / 8);
+
+  // Empty records are ignored for parameter passing purposes.
+  if (isEmptyRecord(getContext(), Ty, true)) {
+    Address Addr(CGF.Builder.CreateLoad(VAListAddr), SlotSize);
+    Addr = CGF.Builder.CreateElementBitCast(Addr, CGF.ConvertTypeForMem(Ty));
+    return Addr;
+  }
+
+  auto SizeAndAlign =
+      getContext().getTypeInfoInChars(Ty);
+
+  // Arguments bigger than 2*Xlen bytes are passed indirectly.
+  bool IsIndirect = SizeAndAlign.Width > 2 * SlotSize;
+
+  return emitVoidPtrVAArg(CGF, VAListAddr, Ty, IsIndirect, SizeAndAlign,
+                          SlotSize, /*AllowHigherAlign=*/true);
+}
+
+ABIArgInfo LoongArchABIInfo::extendType(QualType Ty) const {
+  int TySize = getContext().getTypeSize(Ty);
+  // LP64D ABI requires unsigned 32 bit integers to be sign extended.
+  if (GRLen == 64 && Ty->isUnsignedIntegerOrEnumerationType() && TySize == 32)
+    return ABIArgInfo::getSignExtend(Ty);
+  return ABIArgInfo::getExtend(Ty);
+}
+
+namespace {
+class LoongArchTargetCodeGenInfo : public TargetCodeGenInfo {
+public:
+  LoongArchTargetCodeGenInfo(CodeGen::CodeGenTypes &CGT, unsigned GRLen,
+                         unsigned FRLen)
+      : TargetCodeGenInfo(std::make_unique<LoongArchABIInfo>(
+                          CGT, GRLen, FRLen)) {}
+
+  void setTargetAttributes(const Decl *D, llvm::GlobalValue *GV,
+                           CodeGen::CodeGenModule &CGM) const override {
+    return;
+  }
+};
+} // namespace
+
+//===----------------------------------------------------------------------===//
 // MIPS ABI Implementation.  This works for both little-endian and
 // big-endian variants.
 //===----------------------------------------------------------------------===//
@@ -11434,6 +11971,9 @@
   case llvm::Triple::nvptx64:
     return SetCGInfo(new NVPTXTargetCodeGenInfo(Types));
 
+  case llvm::Triple::loongarch64:
+    return SetCGInfo(new LoongArchTargetCodeGenInfo(Types, 64, 64));
+
   case llvm::Triple::msp430:
     return SetCGInfo(new MSP430TargetCodeGenInfo(Types));
 
diff -uNr llvm-toolchain-14-14.0.6.orig/clang/lib/Driver/CMakeLists.txt llvm-toolchain-14-14.0.6/clang/lib/Driver/CMakeLists.txt
--- llvm-toolchain-14-14.0.6.orig/clang/lib/Driver/CMakeLists.txt	2022-06-25 15:48:33.000000000 +0800
+++ llvm-toolchain-14-14.0.6/clang/lib/Driver/CMakeLists.txt	2023-03-09 13:35:06.279618219 +0800
@@ -27,6 +27,7 @@
   ToolChains/Arch/AArch64.cpp
   ToolChains/Arch/ARM.cpp
   ToolChains/Arch/M68k.cpp
+  ToolChains/Arch/LoongArch.cpp
   ToolChains/Arch/Mips.cpp
   ToolChains/Arch/PPC.cpp
   ToolChains/Arch/RISCV.cpp
diff -uNr llvm-toolchain-14-14.0.6.orig/clang/lib/Driver/Driver.cpp llvm-toolchain-14-14.0.6/clang/lib/Driver/Driver.cpp
--- llvm-toolchain-14-14.0.6.orig/clang/lib/Driver/Driver.cpp	2022-06-25 15:48:33.000000000 +0800
+++ llvm-toolchain-14-14.0.6/clang/lib/Driver/Driver.cpp	2023-03-09 13:35:06.282951330 +0800
@@ -617,6 +617,21 @@
     Target.setVendorName("intel");
   }
 
+  // If target is LoongArch adjust the target triple
+  // accordingly to provided ABI name.
+  A = Args.getLastArg(options::OPT_mabi_EQ);
+  if (A && Target.isLoongArch()) {
+    StringRef ABIName = A->getValue();
+    if (ABIName == "ilp32d" || ABIName == "ilp32f" || ABIName == "ilp32s") {
+      // TODO
+      llvm_unreachable("Unimplemented ABI");
+    } else if (ABIName == "lp64d") {
+      Target = Target.get64BitArchVariant();
+      if (Target.getEnvironment() == llvm::Triple::GNU)
+        Target.setEnvironment(llvm::Triple::GNUABI64);
+    }
+  }
+
   // If target is MIPS adjust the target triple
   // accordingly to provided ABI name.
   A = Args.getLastArg(options::OPT_mabi_EQ);
diff -uNr llvm-toolchain-14-14.0.6.orig/clang/lib/Driver/ToolChains/Arch/LoongArch.cpp llvm-toolchain-14-14.0.6/clang/lib/Driver/ToolChains/Arch/LoongArch.cpp
--- llvm-toolchain-14-14.0.6.orig/clang/lib/Driver/ToolChains/Arch/LoongArch.cpp	1970-01-01 08:00:00.000000000 +0800
+++ llvm-toolchain-14-14.0.6/clang/lib/Driver/ToolChains/Arch/LoongArch.cpp	2023-03-09 13:35:06.282951330 +0800
@@ -0,0 +1,170 @@
+//===--- LoongArch.cpp - Tools Implementations -----------------------*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#include "LoongArch.h"
+#include "ToolChains/CommonArgs.h"
+#include "clang/Driver/Driver.h"
+#include "clang/Driver/DriverDiagnostic.h"
+#include "clang/Driver/Options.h"
+#include "llvm/ADT/StringSwitch.h"
+#include "llvm/Option/ArgList.h"
+
+using namespace clang::driver;
+using namespace clang::driver::tools;
+using namespace clang;
+using namespace llvm::opt;
+
+// Get CPU and ABI names. They are not independent
+// so we have to calculate them together.
+void loongarch::getLoongArchCPUAndABI(const ArgList &Args, const llvm::Triple &Triple,
+                            StringRef &CPUName, StringRef &ABIName) {
+  const char *DefLoongArch32CPU = "loongarch32";
+  const char *DefLoongArch64CPU = "la464";
+
+  if (Arg *A = Args.getLastArg(clang::driver::options::OPT_march_EQ,
+                               options::OPT_mcpu_EQ))
+    CPUName = A->getValue();
+
+  if (Arg *A = Args.getLastArg(options::OPT_mabi_EQ))
+    ABIName = A->getValue();
+
+  // Setup default CPU and ABI names.
+  if (CPUName.empty() && ABIName.empty()) {
+    switch (Triple.getArch()) {
+    default:
+      llvm_unreachable("Unexpected triple arch name");
+    case llvm::Triple::loongarch32:
+      CPUName = DefLoongArch32CPU;
+      break;
+    case llvm::Triple::loongarch64:
+      CPUName = DefLoongArch64CPU;
+      break;
+    }
+  }
+
+  if (ABIName.empty()) {
+    ABIName = llvm::StringSwitch<const char *>(CPUName)
+                  .Case("loongarch32", "ilp32d")
+                  .Case("la464", "lp64d")
+                  .Default(Triple.isLoongArch32() ? "ilp32d" : "lp64d");
+  }
+
+  if (CPUName.empty()) {
+    // Deduce CPU name from ABI name.
+    CPUName = llvm::StringSwitch<const char *>(ABIName)
+                  .Cases("lp64d", "lp64f", "lp64s", DefLoongArch64CPU)
+                  .Default("");
+  }
+
+  if (Arg *A = Args.getLastArg(options::OPT_msingle_float,
+                               options::OPT_mdouble_float,
+                               options::OPT_msoft_float)) {
+    if (A->getOption().matches(options::OPT_msingle_float))
+      ABIName = "lp64f";
+    else if (A->getOption().matches(options::OPT_mdouble_float))
+      ABIName = "lp64d";
+    else
+      ABIName = "lp64s";
+  }
+
+  // FIXME: Warn on inconsistent use of -march and -mabi.
+}
+
+std::string loongarch::getLoongArchABILibSuffix(const ArgList &Args,
+                                      const llvm::Triple &Triple) {
+  StringRef CPUName, ABIName;
+  tools::loongarch::getLoongArchCPUAndABI(Args, Triple, CPUName, ABIName);
+  return llvm::StringSwitch<std::string>(ABIName)
+      .Cases("ilp32d", "ilp32f", "ilp32s", "32")
+      .Cases("lp64d", "lp64f", "lp64s", "64");
+}
+
+void loongarch::getLoongArchTargetFeatures(const Driver &D, const llvm::Triple &Triple,
+                                 const ArgList &Args,
+                                 std::vector<StringRef> &Features) {
+  StringRef CPUName;
+  StringRef ABIName;
+  StringRef FPUValue;
+  getLoongArchCPUAndABI(Args, Triple, CPUName, ABIName);
+
+  bool NonPIC = false;
+
+  Arg *LastPICArg = Args.getLastArg(options::OPT_fPIC, options::OPT_fno_PIC,
+                                    options::OPT_fpic, options::OPT_fno_pic,
+                                    options::OPT_fPIE, options::OPT_fno_PIE,
+                                    options::OPT_fpie, options::OPT_fno_pie);
+  if (LastPICArg) {
+    Option O = LastPICArg->getOption();
+    NonPIC =
+        (O.matches(options::OPT_fno_PIC) || O.matches(options::OPT_fno_pic) ||
+         O.matches(options::OPT_fno_PIE) || O.matches(options::OPT_fno_pie));
+  }
+
+  if (NonPIC) {
+    NonPIC = false;
+  }
+
+  if (Arg *A = Args.getLastArg(options::OPT_mfpu_EQ))
+    FPUValue = A->getValue();
+
+  if (Arg *A = Args.getLastArg(options::OPT_msingle_float,
+                               options::OPT_mdouble_float,
+                               options::OPT_msoft_float)) {
+    if (A->getOption().matches(options::OPT_msingle_float))
+      FPUValue = "32";
+    else if (A->getOption().matches(options::OPT_mdouble_float))
+      FPUValue = "64";
+    else
+      FPUValue = "none";
+  }
+
+  // Setup feature.
+  if (FPUValue.empty())
+    Features.push_back("+d");
+  else {
+    if (FPUValue == "64")
+      Features.push_back("+d");
+    else if (FPUValue == "32")
+      Features.push_back("+f");
+    else if (FPUValue == "none") {
+      Features.push_back("-f");
+      Features.push_back("-d");
+    } else
+      D.Diag(clang::diag::err_drv_invalid_loongarch_mfpu)
+          << FPUValue;
+  }
+
+  // lp64f ABI and -mfpu=none are incompatible.
+  if (hasLoongArchAbiArg(Args, "lp64f") && hasLoongArchFpuArg(Args, "none")) {
+    D.Diag(clang::diag::err_opt_not_valid_with_opt) << "lp64f"
+                                                    << "-mfpu=none";
+  }
+
+  // Also lp64d ABI is only compatible with -mfpu=64.
+  if ((hasLoongArchAbiArg(Args, "lp64d") || ABIName == "lp64d") &&
+      (hasLoongArchFpuArg(Args, "none") || hasLoongArchFpuArg(Args, "32"))) {
+    D.Diag(clang::diag::err_opt_not_valid_without_opt) << "lp64d"
+                                                       << "-mfpu=64";
+  }
+}
+
+bool loongarch::hasLoongArchAbiArg(const ArgList &Args, const char *Value) {
+  Arg *A = Args.getLastArg(options::OPT_mabi_EQ);
+  return A && (A->getValue() == StringRef(Value));
+}
+
+bool loongarch::isUCLibc(const ArgList &Args) {
+  Arg *A = Args.getLastArg(options::OPT_m_libc_Group);
+  return A && A->getOption().matches(options::OPT_muclibc);
+}
+
+bool loongarch::hasLoongArchFpuArg(const ArgList &Args, const char *Value) {
+  Arg *A = Args.getLastArg(options::OPT_mfpu_EQ);
+  return A && (A->getValue() == StringRef(Value));
+}
diff -uNr llvm-toolchain-14-14.0.6.orig/clang/lib/Driver/ToolChains/Arch/LoongArch.h llvm-toolchain-14-14.0.6/clang/lib/Driver/ToolChains/Arch/LoongArch.h
--- llvm-toolchain-14-14.0.6.orig/clang/lib/Driver/ToolChains/Arch/LoongArch.h	1970-01-01 08:00:00.000000000 +0800
+++ llvm-toolchain-14-14.0.6/clang/lib/Driver/ToolChains/Arch/LoongArch.h	2023-03-09 13:35:06.282951330 +0800
@@ -0,0 +1,42 @@
+//===--- LoongArch.h - LoongArch-specific Tool Helpers ----------------------*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_LIB_DRIVER_TOOLCHAINS_ARCH_LOONGARCH_H
+#define LLVM_CLANG_LIB_DRIVER_TOOLCHAINS_ARCH_LOONGARCH_H
+
+#include "clang/Driver/Driver.h"
+#include "llvm/ADT/StringRef.h"
+#include "llvm/ADT/Triple.h"
+#include "llvm/Option/Option.h"
+#include <string>
+#include <vector>
+
+namespace clang {
+namespace driver {
+namespace tools {
+
+namespace loongarch {
+void getLoongArchCPUAndABI(const llvm::opt::ArgList &Args,
+                      const llvm::Triple &Triple, StringRef &CPUName,
+                      StringRef &ABIName);
+void getLoongArchTargetFeatures(const Driver &D, const llvm::Triple &Triple,
+                           const llvm::opt::ArgList &Args,
+                           std::vector<StringRef> &Features);
+std::string getLoongArchABILibSuffix(const llvm::opt::ArgList &Args,
+                                const llvm::Triple &Triple);
+bool hasLoongArchAbiArg(const llvm::opt::ArgList &Args, const char *Value);
+bool hasLoongArchFpuArg(const llvm::opt::ArgList &Args, const char *Value);
+bool isUCLibc(const llvm::opt::ArgList &Args);
+
+} // end namespace loongarch
+} // end namespace target
+} // end namespace driver
+} // end namespace clang
+
+#endif // LLVM_CLANG_LIB_DRIVER_TOOLCHAINS_ARCH_LOONGARCH_H
diff -uNr llvm-toolchain-14-14.0.6.orig/clang/lib/Driver/ToolChains/Clang.cpp llvm-toolchain-14-14.0.6/clang/lib/Driver/ToolChains/Clang.cpp
--- llvm-toolchain-14-14.0.6.orig/clang/lib/Driver/ToolChains/Clang.cpp	2022-06-25 15:48:33.000000000 +0800
+++ llvm-toolchain-14-14.0.6/clang/lib/Driver/ToolChains/Clang.cpp	2023-03-09 13:35:06.286284441 +0800
@@ -11,6 +11,7 @@
 #include "Arch/AArch64.h"
 #include "Arch/ARM.h"
 #include "Arch/M68k.h"
+#include "Arch/LoongArch.h"
 #include "Arch/Mips.h"
 #include "Arch/PPC.h"
 #include "Arch/RISCV.h"
@@ -331,6 +332,11 @@
     arm::getARMTargetFeatures(D, Triple, Args, CmdArgs, Features, ForAS);
     break;
 
+  case llvm::Triple::loongarch32:
+  case llvm::Triple::loongarch64:
+    loongarch::getLoongArchTargetFeatures(D, Triple, Args, Features);
+    break;
+
   case llvm::Triple::ppc:
   case llvm::Triple::ppcle:
   case llvm::Triple::ppc64:
@@ -535,6 +541,8 @@
     // XCore never wants frame pointers, regardless of OS.
     // WebAssembly never wants frame pointers.
     return false;
+  case llvm::Triple::loongarch64:
+  case llvm::Triple::loongarch32:
   case llvm::Triple::ppc:
   case llvm::Triple::ppcle:
   case llvm::Triple::ppc64:
@@ -1751,6 +1759,11 @@
     CmdArgs.push_back("-fallow-half-arguments-and-returns");
     break;
 
+  case llvm::Triple::loongarch32:
+  case llvm::Triple::loongarch64:
+    AddLoongArchTargetArgs(Args, CmdArgs);
+    break;
+
   case llvm::Triple::mips:
   case llvm::Triple::mipsel:
   case llvm::Triple::mips64:
@@ -1895,6 +1908,41 @@
   }
 }
 
+void Clang::AddLoongArchTargetArgs(const ArgList &Args,
+                                   ArgStringList &CmdArgs) const {
+  const Driver &D = getToolChain().getDriver();
+  StringRef CPUName;
+  StringRef ABIName;
+  const llvm::Triple &Triple = getToolChain().getTriple();
+  loongarch::getLoongArchCPUAndABI(Args, Triple, CPUName, ABIName);
+
+  CmdArgs.push_back("-target-abi");
+  CmdArgs.push_back(ABIName.data());
+
+  if (Arg *A = Args.getLastArg(options::OPT_mcheck_zero_division,
+                               options::OPT_mno_check_zero_division)) {
+    if (A->getOption().matches(options::OPT_mno_check_zero_division)) {
+      CmdArgs.push_back("-mllvm");
+      CmdArgs.push_back("-mnocheck-zero-division");
+    }
+  }
+
+  llvm::Reloc::Model RelocationModel;
+  unsigned PICLevel;
+  bool IsPIE;
+  std::tie(RelocationModel, PICLevel, IsPIE) =
+      ParsePICArgs(getToolChain(), Args);
+
+  if (Arg *A = Args.getLastArg(options::OPT_mfix_loongson3_llsc,
+                               options::OPT_mno_fix_loongson3_llsc)) {
+    CmdArgs.push_back("-mllvm");
+    if (A->getOption().matches(options::OPT_mfix_loongson3_llsc))
+      CmdArgs.push_back("-loongarch-fix-loongson3-llsc=1");
+    else
+      CmdArgs.push_back("-loongarch-fix-loongson3-llsc=0");
+  }
+}
+
 void Clang::AddMIPSTargetArgs(const ArgList &Args,
                               ArgStringList &CmdArgs) const {
   const Driver &D = getToolChain().getDriver();
@@ -7627,6 +7675,17 @@
 
 // Begin ClangAs
 
+void ClangAs::AddLoongArchTargetArgs(const ArgList &Args,
+                                     ArgStringList &CmdArgs) const {
+  StringRef CPUName;
+  StringRef ABIName;
+  const llvm::Triple &Triple = getToolChain().getTriple();
+  loongarch::getLoongArchCPUAndABI(Args, Triple, CPUName, ABIName);
+
+  CmdArgs.push_back("-target-abi");
+  CmdArgs.push_back(ABIName.data());
+}
+
 void ClangAs::AddMIPSTargetArgs(const ArgList &Args,
                                 ArgStringList &CmdArgs) const {
   StringRef CPUName;
@@ -7816,6 +7875,11 @@
   default:
     break;
 
+  case llvm::Triple::loongarch32:
+  case llvm::Triple::loongarch64:
+    AddLoongArchTargetArgs(Args, CmdArgs);
+    break;
+
   case llvm::Triple::mips:
   case llvm::Triple::mipsel:
   case llvm::Triple::mips64:
diff -uNr llvm-toolchain-14-14.0.6.orig/clang/lib/Driver/ToolChains/Clang.h llvm-toolchain-14-14.0.6/clang/lib/Driver/ToolChains/Clang.h
--- llvm-toolchain-14-14.0.6.orig/clang/lib/Driver/ToolChains/Clang.h	2022-06-25 15:48:33.000000000 +0800
+++ llvm-toolchain-14-14.0.6/clang/lib/Driver/ToolChains/Clang.h	2023-03-09 13:35:06.286284441 +0800
@@ -57,6 +57,8 @@
                         bool KernelOrKext) const;
   void AddARM64TargetArgs(const llvm::opt::ArgList &Args,
                           llvm::opt::ArgStringList &CmdArgs) const;
+  void AddLoongArchTargetArgs(const llvm::opt::ArgList &Args,
+                              llvm::opt::ArgStringList &CmdArgs) const;
   void AddMIPSTargetArgs(const llvm::opt::ArgList &Args,
                          llvm::opt::ArgStringList &CmdArgs) const;
   void AddPPCTargetArgs(const llvm::opt::ArgList &Args,
@@ -123,6 +125,8 @@
 public:
   ClangAs(const ToolChain &TC)
       : Tool("clang::as", "clang integrated assembler", TC) {}
+  void AddLoongArchTargetArgs(const llvm::opt::ArgList &Args,
+                              llvm::opt::ArgStringList &CmdArgs) const;
   void AddMIPSTargetArgs(const llvm::opt::ArgList &Args,
                          llvm::opt::ArgStringList &CmdArgs) const;
   void AddX86TargetArgs(const llvm::opt::ArgList &Args,
diff -uNr llvm-toolchain-14-14.0.6.orig/clang/lib/Driver/ToolChains/CommonArgs.cpp llvm-toolchain-14-14.0.6/clang/lib/Driver/ToolChains/CommonArgs.cpp
--- llvm-toolchain-14-14.0.6.orig/clang/lib/Driver/ToolChains/CommonArgs.cpp	2022-06-25 15:48:33.000000000 +0800
+++ llvm-toolchain-14-14.0.6/clang/lib/Driver/ToolChains/CommonArgs.cpp	2023-03-09 13:35:06.286284441 +0800
@@ -10,6 +10,7 @@
 #include "Arch/AArch64.h"
 #include "Arch/ARM.h"
 #include "Arch/M68k.h"
+#include "Arch/LoongArch.h"
 #include "Arch/Mips.h"
 #include "Arch/PPC.h"
 #include "Arch/SystemZ.h"
@@ -386,6 +387,14 @@
   case llvm::Triple::m68k:
     return m68k::getM68kTargetCPU(Args);
 
+  case llvm::Triple::loongarch32:
+  case llvm::Triple::loongarch64: {
+    StringRef CPUName;
+    StringRef ABIName;
+    loongarch::getLoongArchCPUAndABI(Args, T, CPUName, ABIName);
+    return std::string(CPUName);
+  }
+
   case llvm::Triple::mips:
   case llvm::Triple::mipsel:
   case llvm::Triple::mips64:
@@ -1321,6 +1330,18 @@
   if ((ROPI || RWPI) && (PIC || PIE))
     ToolChain.getDriver().Diag(diag::err_drv_ropi_rwpi_incompatible_with_pic);
 
+  if (Triple.isLoongArch()) {
+    StringRef CPUName;
+    StringRef ABIName;
+    loongarch::getLoongArchCPUAndABI(Args, Triple, CPUName, ABIName);
+    // When targeting the LP64D ABI, PIC is the default.
+    if (ABIName == "lp64d")
+      PIC = true;
+    // Unlike other architectures, LoongArch, even with -fPIC/-mxgot/multigot,
+    // does not use PIC level 2 for historical reasons.
+    IsPICLevelTwo = false;
+  }
+
   if (Triple.isMIPS()) {
     StringRef CPUName;
     StringRef ABIName;
diff -uNr llvm-toolchain-14-14.0.6.orig/clang/lib/Driver/ToolChains/Gnu.cpp llvm-toolchain-14-14.0.6/clang/lib/Driver/ToolChains/Gnu.cpp
--- llvm-toolchain-14-14.0.6.orig/clang/lib/Driver/ToolChains/Gnu.cpp	2022-06-25 15:48:33.000000000 +0800
+++ llvm-toolchain-14-14.0.6/clang/lib/Driver/ToolChains/Gnu.cpp	2023-03-09 13:35:06.289617552 +0800
@@ -8,6 +8,7 @@
 
 #include "Gnu.h"
 #include "Arch/ARM.h"
+#include "Arch/LoongArch.h"
 #include "Arch/Mips.h"
 #include "Arch/PPC.h"
 #include "Arch/RISCV.h"
@@ -256,6 +257,10 @@
     return isArmBigEndian(T, Args) ? "armelfb_linux_eabi" : "armelf_linux_eabi";
   case llvm::Triple::m68k:
     return "m68kelf";
+  case llvm::Triple::loongarch32:
+    return "elf32loongarch";
+  case llvm::Triple::loongarch64:
+    return "elf64loongarch";
   case llvm::Triple::ppc:
     if (T.isOSLinux())
       return "elf32ppclinux";
@@ -822,6 +827,41 @@
 
     break;
   }
+  case llvm::Triple::loongarch32:
+  case llvm::Triple::loongarch64: {
+    StringRef CPUName;
+    StringRef ABIName;
+    loongarch::getLoongArchCPUAndABI(Args, getToolChain().getTriple(), CPUName, ABIName);
+
+    //FIXME: Currently gnu as doesn't support -march
+    //CmdArgs.push_back("-march=loongarch");
+    //CmdArgs.push_back(CPUName.data());
+
+    CmdArgs.push_back("-mabi=lp64d");
+
+    // -mno-shared should be emitted unless -fpic, -fpie, -fPIC, -fPIE,
+    // or -mshared (not implemented) is in effect.
+    if (RelocationModel == llvm::Reloc::Static)
+      CmdArgs.push_back("-mno-shared");
+
+    break;
+
+    // Add the last -mfp32/-mfp64.
+    if (Arg *A = Args.getLastArg(options::OPT_mfp32,
+                                 options::OPT_mfp64)) {
+      A->claim();
+      A->render(Args, CmdArgs);
+    }
+
+    Args.AddLastArg(CmdArgs, options::OPT_mhard_float,
+                    options::OPT_msoft_float);
+
+    Args.AddLastArg(CmdArgs, options::OPT_mdouble_float,
+                    options::OPT_msingle_float);
+
+    AddAssemblerKPIC(getToolChain(), Args, CmdArgs);
+    break;
+  }
   case llvm::Triple::mips:
   case llvm::Triple::mipsel:
   case llvm::Triple::mips64:
@@ -2122,6 +2162,11 @@
   static const char *const MIPSELTriples[] = {
       "mipsel-linux-gnu", "mips-img-linux-gnu", "mipsisa32r6el-linux-gnu"};
 
+  static const char *const LoongArch64LibDirs[] = {"/lib64", "/lib"};
+  static const char *const LoongArch64Triples[] = {
+      "loongarch64-linux-gnu",         "loongarch64-linux-gnuabi64",
+      "loongarch64-unknown-linux-gnu", "loongarch64-unknown-linux-gnuabi64"};
+
   static const char *const MIPS64LibDirs[] = {"/lib64", "/lib"};
   static const char *const MIPS64Triples[] = {
       "mips64-linux-gnu",      "mips-mti-linux-gnu",
@@ -2357,6 +2402,10 @@
     LibDirs.append(begin(M68kLibDirs), end(M68kLibDirs));
     TripleAliases.append(begin(M68kTriples), end(M68kTriples));
     break;
+  case llvm::Triple::loongarch64:
+    LibDirs.append(begin(LoongArch64LibDirs), end(LoongArch64LibDirs));
+    TripleAliases.append(begin(LoongArch64Triples), end(LoongArch64Triples));
+    break;
   case llvm::Triple::mips:
     LibDirs.append(begin(MIPSLibDirs), end(MIPSLibDirs));
     TripleAliases.append(begin(MIPSTriples), end(MIPSTriples));
@@ -2708,6 +2757,7 @@
   switch (getArch()) {
   case llvm::Triple::x86_64:
     return getTriple().isOSWindows();
+  case llvm::Triple::loongarch64:
   case llvm::Triple::mips64:
   case llvm::Triple::mips64el:
     return true;
@@ -2750,6 +2800,8 @@
   case llvm::Triple::mips64el:
   case llvm::Triple::msp430:
   case llvm::Triple::m68k:
+  case llvm::Triple::loongarch32:
+  case llvm::Triple::loongarch64:
     return true;
   case llvm::Triple::sparc:
   case llvm::Triple::sparcel:
diff -uNr llvm-toolchain-14-14.0.6.orig/clang/lib/Driver/ToolChains/Linux.cpp llvm-toolchain-14-14.0.6/clang/lib/Driver/ToolChains/Linux.cpp
--- llvm-toolchain-14-14.0.6.orig/clang/lib/Driver/ToolChains/Linux.cpp	2023-03-09 13:33:12.000000000 +0800
+++ llvm-toolchain-14-14.0.6/clang/lib/Driver/ToolChains/Linux.cpp	2023-03-09 13:37:37.989507734 +0800
@@ -8,6 +8,7 @@
 
 #include "Linux.h"
 #include "Arch/ARM.h"
+#include "Arch/LoongArch.h"
 #include "Arch/Mips.h"
 #include "Arch/PPC.h"
 #include "Arch/RISCV.h"
@@ -86,6 +87,12 @@
   case llvm::Triple::aarch64_be:
     return "aarch64_be-linux-gnu";
 
+  case llvm::Triple::loongarch32:
+    return "loongarch32-linux-gnu";
+
+  case llvm::Triple::loongarch64:
+    return "loongarch64-linux-gnu";
+
   case llvm::Triple::m68k:
     return "m68k-linux-gnu";
 
@@ -461,6 +468,16 @@
     LibDir = "lib";
     Loader = "ld.so.1";
     break;
+
+  case llvm::Triple::loongarch32:
+  case llvm::Triple::loongarch64: {
+    StringRef CPUName, ABIName;
+    tools::loongarch::getLoongArchCPUAndABI(Args, Triple, CPUName, ABIName);
+    LibDir = "lib" + tools::loongarch::getLoongArchABILibSuffix(Args, Triple);
+    Loader = ("ld-linux-loongarch-" + ABIName + ".so.1").str();
+    break;
+  }
+
   case llvm::Triple::mips:
   case llvm::Triple::mipsel:
   case llvm::Triple::mips64:
@@ -480,6 +497,7 @@
 
     break;
   }
+
   case llvm::Triple::ppc:
     LibDir = "lib";
     Loader = "ld.so.1";
diff -uNr llvm-toolchain-14-14.0.6.orig/clang/lib/Driver/XRayArgs.cpp llvm-toolchain-14-14.0.6/clang/lib/Driver/XRayArgs.cpp
--- llvm-toolchain-14-14.0.6.orig/clang/lib/Driver/XRayArgs.cpp	2022-02-04 15:20:58.000000000 +0800
+++ llvm-toolchain-14-14.0.6/clang/lib/Driver/XRayArgs.cpp	2023-03-09 13:35:06.289617552 +0800
@@ -42,6 +42,8 @@
     case llvm::Triple::aarch64:
     case llvm::Triple::hexagon:
     case llvm::Triple::ppc64le:
+    case llvm::Triple::loongarch32:
+    case llvm::Triple::loongarch64:
     case llvm::Triple::mips:
     case llvm::Triple::mipsel:
     case llvm::Triple::mips64:
diff -uNr llvm-toolchain-14-14.0.6.orig/clang/lib/Headers/CMakeLists.txt llvm-toolchain-14-14.0.6/clang/lib/Headers/CMakeLists.txt
--- llvm-toolchain-14-14.0.6.orig/clang/lib/Headers/CMakeLists.txt	2022-06-25 15:48:33.000000000 +0800
+++ llvm-toolchain-14-14.0.6/clang/lib/Headers/CMakeLists.txt	2023-03-09 13:35:06.289617552 +0800
@@ -85,6 +85,7 @@
   invpcidintrin.h
   iso646.h
   keylockerintrin.h
+  larchintrin.h
   limits.h
   lwpintrin.h
   lzcntintrin.h
diff -uNr llvm-toolchain-14-14.0.6.orig/clang/lib/Headers/larchintrin.h llvm-toolchain-14-14.0.6/clang/lib/Headers/larchintrin.h
--- llvm-toolchain-14-14.0.6.orig/clang/lib/Headers/larchintrin.h	1970-01-01 08:00:00.000000000 +0800
+++ llvm-toolchain-14-14.0.6/clang/lib/Headers/larchintrin.h	2023-03-09 13:35:06.289617552 +0800
@@ -0,0 +1,320 @@
+//===----------- larchintrin.h - LoongArch BASE intrinsics ------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file contains the LoongArch Base intrinsics
+//
+//===----------------------------------------------------------------------===//
+#ifndef __LOONGARCH_BASE_H
+#define __LOONGARCH_BASE_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct drdtime{
+	unsigned long dvalue;
+	unsigned long dtimeid;
+} __drdtime_t;
+
+typedef struct rdtime{
+	unsigned int value;
+	unsigned int timeid;
+} __rdtime_t;
+
+/* Assembly instruction format:          rd, csr_num */
+/* Data types in instruction templates:  unsigned int, uimm14_32 */
+#define __csrrd(/*uimm14_32*/ _1)	((unsigned int)__builtin_loongarch_csrrd(_1))
+
+/* Assembly instruction format:          rd, csr_num */
+/* Data types in instruction templates:  unsigned int, uimm14_32 */
+#define __csrwr(/*unsigned int*/ _1, /*uimm14_32*/ _2)	((unsigned int)__builtin_loongarch_csrwr((unsigned int)(_1), (_2)))
+
+/* Assembly instruction format:          rd, rj, csr_num */
+/* Data types in instruction templates:  unsigned int, unsigned int, uimm14_32 */
+#define __csrxchg(/*unsigned int*/ _1, /*unsigned int*/ _2, /*uimm14_32*/ _3) ((unsigned int)__builtin_loongarch_csrxchg((unsigned int)(_1), (unsigned int)(_2), (_3)))
+
+/* Assembly instruction format:          rd, csr_num */
+/* Data types in instruction templates:  unsigned long int, uimm14 */
+#define __dcsrrd(/*uimm14*/ _1)	((unsigned long int)__builtin_loongarch_dcsrrd(_1))
+
+/* Assembly instruction format:          rd, csr_num */
+/* Data types in instruction templates:  unsigned long int, uimm14 */
+#define __dcsrwr(/*unsigned long int*/ _1, /*uimm14*/ _2)	((unsigned long int)__builtin_loongarch_dcsrwr((unsigned long int)(_1), (_2)))
+
+/* Assembly instruction format:          rd, rj, csr_num */
+/* Data types in instruction templates:  unsigned long int, unsigned long int, uimm14 */
+#define __dcsrxchg(/*unsigned long int*/ _1, /*unsigned long int*/ _2, /*uimm14*/ _3) ((unsigned long int)__builtin_loongarch_dcsrxchg((unsigned long int)(_1), (unsigned long int)(_2), (_3)))
+
+/* Assembly instruction format:          rd, rj */
+/* Data types in instruction templates:  unsigned char, unsigned int */
+extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+unsigned char __iocsrrd_b(unsigned int _1)
+{
+	return (unsigned char)__builtin_loongarch_iocsrrd_b((unsigned int)_1);
+}
+
+/* Assembly instruction format:          rd, rj */
+/* Data types in instruction templates:  unsigned short, unsigned int */
+extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+unsigned short __iocsrrd_h(unsigned int _1)
+{
+	return (unsigned short)__builtin_loongarch_iocsrrd_h((unsigned int)_1);
+}
+
+/* Assembly instruction format:          rd, rj */
+/* Data types in instruction templates:  unsigned int, unsigned int */
+extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+unsigned int __iocsrrd_w(unsigned int _1)
+{
+	return (unsigned int)__builtin_loongarch_iocsrrd_w((unsigned int)_1);
+}
+
+/* Assembly instruction format:          rd, rj */
+/* Data types in instruction templates: unsigned long int, unsigned int */
+extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+unsigned long int __iocsrrd_d(unsigned int _1)
+{
+	return (unsigned long int)__builtin_loongarch_iocsrrd_d((unsigned int)_1);
+}
+
+/* Assembly instruction format:          rd, rj */
+/* Data types in instruction templates:  unsigned char, unsigned int */
+extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+void __iocsrwr_b(unsigned char _1, unsigned int _2)
+{
+	return (void)__builtin_loongarch_iocsrwr_b((unsigned char)_1, (unsigned int)_2);
+}
+
+/* Assembly instruction format:          rd, rj */
+/* Data types in instruction templates:  unsigned short, unsigned int */
+extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+void __iocsrwr_h(unsigned short _1, unsigned int _2)
+{
+	return (void)__builtin_loongarch_iocsrwr_h((unsigned short)_1, (unsigned int)_2);
+}
+
+/* Assembly instruction format:          rd, rj */
+/* Data types in instruction templates:  unsigned int, unsigned int */
+extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+void __iocsrwr_w(unsigned int _1, unsigned int _2)
+{
+	return (void)__builtin_loongarch_iocsrwr_w((unsigned int)_1, (unsigned int)_2);
+}
+
+/* Assembly instruction format:          rd, rj */
+/* Data types in instruction templates: unsigned long int, unsigned int */
+extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+void __iocsrwr_d(unsigned long int _1, unsigned int _2)
+{
+	return (void)__builtin_loongarch_iocsrwr_d((unsigned long int)_1, (unsigned int)_2);
+}
+
+/* Assembly instruction format:          op, rj, si12 */
+/* Data types in instruction templates: uimm5, unsigned int, simm12 */
+#define __cacop(/*uimm5*/ _1, /*unsigned int*/ _2, /*simm12*/ _3) ((void)__builtin_loongarch_cacop((_1), (unsigned int)(_2), (_3)))
+
+/* Assembly instruction format:          op, rj, si12 */
+/* Data types in instruction templates: uimm5, unsigned long int, simm12 */
+#define __dcacop(/*uimm5*/ _1, /*unsigned long int*/ _2, /*simm12*/ _3)	((void)__builtin_loongarch_dcacop((_1), (unsigned long int)(_2), (_3)))
+
+#define __rdtime_d	__builtin_loongarch_rdtime_d
+#define __rdtimel_w	__builtin_loongarch_rdtimel_w
+#define __rdtimeh_w	__builtin_loongarch_rdtimeh_w
+
+extern __inline __drdtime_t __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+__builtin_loongarch_rdtime_d (void)
+{
+  __drdtime_t drdtime;
+  __asm__ volatile (
+    "rdtime.d\t%[val],%[tid]\n\t"
+    : [val]"=&r"(drdtime.dvalue),[tid]"=&r"(drdtime.dtimeid)
+    :
+  );
+  return drdtime;
+}
+
+extern __inline __rdtime_t __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+__builtin_loongarch_rdtimeh_w (void)
+{
+  __rdtime_t rdtime;
+  __asm__ volatile (
+    "rdtimeh.w\t%[val],%[tid]\n\t"
+    : [val]"=&r"(rdtime.value),[tid]"=&r"(rdtime.timeid)
+    :
+  );
+  return rdtime;
+}
+
+extern __inline __rdtime_t __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+__builtin_loongarch_rdtimel_w (void)
+{
+  __rdtime_t rdtime;
+  __asm__ volatile (
+    "rdtimel.w\t%[val],%[tid]\n\t"
+    : [val]"=&r"(rdtime.value),[tid]"=&r"(rdtime.timeid)
+    :
+  );
+  return rdtime;
+}
+
+/* Assembly instruction format:          rd, rj, rk */
+/* Data types in instruction templates:  int, char, int */
+extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+int __crc_w_b_w(char _1, int _2)
+{
+	return (int)__builtin_loongarch_crc_w_b_w((char)_1, (int)_2);
+}
+
+/* Assembly instruction format:          rd, rj, rk */
+/* Data types in instruction templates:  int, short, int */
+extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+int __crc_w_h_w(short _1, int _2)
+{
+	return (int)__builtin_loongarch_crc_w_h_w((short)_1, (int)_2);
+}
+
+/* Assembly instruction format:          rd, rj, rk */
+/* Data types in instruction templates:  int, int, int */
+extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+int __crc_w_w_w(int _1, int _2)
+{
+	return (int)__builtin_loongarch_crc_w_w_w((int)_1, (int)_2);
+}
+
+/* Assembly instruction format:          rd, rj, rk */
+/* Data types in instruction templates: int, long int, int */
+extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+int __crc_w_d_w(long int _1, int _2)
+{
+	return (int)__builtin_loongarch_crc_w_d_w((long int)_1, (int)_2);
+}
+
+/* Assembly instruction format:          rd, rj, rk */
+/* Data types in instruction templates:  int, char, int */
+extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+int __crcc_w_b_w(char _1, int _2)
+{
+	return (int)__builtin_loongarch_crcc_w_b_w((char)_1, (int)_2);
+}
+
+/* Assembly instruction format:          rd, rj, rk */
+/* Data types in instruction templates:  int, short, int */
+extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+int __crcc_w_h_w(short _1, int _2)
+{
+	return (int)__builtin_loongarch_crcc_w_h_w((short)_1, (int)_2);
+}
+
+/* Assembly instruction format:          rd, rj, rk */
+/* Data types in instruction templates:  int, int, int */
+extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+int __crcc_w_w_w(int _1, int _2)
+{
+	return (int)__builtin_loongarch_crcc_w_w_w((int)_1, (int)_2);
+}
+
+/* Assembly instruction format:          rd, rj, rk */
+/* Data types in instruction templates: int, long int, int */
+extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+int __crcc_w_d_w(long int _1, int _2)
+{
+	return (int)__builtin_loongarch_crcc_w_d_w((long int)_1, (int)_2);
+}
+
+extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+void __tlbclr()
+{
+	return (void)__builtin_loongarch_tlbclr();
+}
+
+extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+void __tlbflush()
+{
+	return (void)__builtin_loongarch_tlbflush();
+}
+
+extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+void __tlbfill()
+{
+	return (void)__builtin_loongarch_tlbfill();
+}
+
+extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+void __tlbrd()
+{
+	return (void)__builtin_loongarch_tlbrd();
+}
+
+extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+void __tlbwr()
+{
+	return (void)__builtin_loongarch_tlbwr();
+}
+
+extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+void __tlbsrch()
+{
+	return (void)__builtin_loongarch_tlbsrch();
+}
+
+/* Assembly instruction format:          code */
+/* Data types in instruction templates:  uimm15 */
+#define __syscall(/*uimm15*/ _1)	((void)__builtin_loongarch_syscall(_1))
+
+/* Assembly instruction format:          code */
+/* Data types in instruction templates:  uimm15 */
+#define __break(/*uimm15*/ _1)	((void)__builtin_loongarch_break(_1))
+
+/* Assembly instruction format:          hint */
+/* Data types in instruction templates:  uimm15 */
+#define __dbar(/*uimm15*/ _1)	((void)__builtin_loongarch_dbar(_1))
+
+/* Assembly instruction format:          hint */
+/* Data types in instruction templates:  uimm15 */
+#define __ibar(/*uimm15*/ _1)	((void)__builtin_loongarch_ibar(_1))
+
+/* Assembly instruction format:          rj, rk */
+/* Data types in instruction templates:  long int, long int */
+extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+void __asrtle_d(long int _1, long int _2)
+{
+	return (void)__builtin_loongarch_asrtle_d((long int)_1, (long int)_2);
+}
+
+/* Assembly instruction format:          rj, rk */
+/* Data types in instruction templates:  long int, long int */
+extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+void __asrtgt_d(long int _1, long int _2)
+{
+	return (void)__builtin_loongarch_asrtgt_d((long int)_1, (long int)_2);
+}
+
+#define __movfcsr2gr(uimm5) \
+({ \
+  unsigned int rd; \
+  __asm__ volatile ( \
+    "movfcsr2gr %0, $fcsr" #uimm5 \
+    : "=&r"(rd) \
+    : \
+  ); rd; \
+})
+
+#define __movgr2fcsr(uimm5, rj) \
+{ \
+  __asm__ volatile ( \
+    "movgr2fcsr $fcsr" #uimm5 ", %0" \
+    : \
+    : "r" (rj) \
+  ); \
+}
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* __LOONGARCH_BASE_H */
diff -uNr llvm-toolchain-14-14.0.6.orig/clang/lib/Sema/SemaChecking.cpp llvm-toolchain-14-14.0.6/clang/lib/Sema/SemaChecking.cpp
--- llvm-toolchain-14-14.0.6.orig/clang/lib/Sema/SemaChecking.cpp	2023-03-09 13:33:12.000000000 +0800
+++ llvm-toolchain-14-14.0.6/clang/lib/Sema/SemaChecking.cpp	2023-03-09 13:35:06.296283774 +0800
@@ -1658,6 +1658,9 @@
   case llvm::Triple::riscv32:
   case llvm::Triple::riscv64:
     return CheckRISCVBuiltinFunctionCall(TI, BuiltinID, TheCall);
+  case llvm::Triple::loongarch32:
+  case llvm::Triple::loongarch64:
+    return CheckLoongArchBuiltinFunctionCall(TI, BuiltinID, TheCall);
   }
 }
 
@@ -4032,6 +4035,45 @@
   return false;
 }
 
+// CheckLoongArchBuiltinFunctionCall - Checks the constant value passed to the
+// intrinsic is correct.
+//
+// FIXME: The size tests here should instead be tablegen'd along with the
+//        definitions from include/clang/Basic/BuiltinsLoongArch.def.
+// FIXME: GCC is strict on signedness for some of these intrinsics, we should
+//        be too.
+bool Sema::CheckLoongArchBuiltinFunctionCall(const TargetInfo &TI,
+                                             unsigned BuiltinID,
+                                             CallExpr *TheCall) {
+  unsigned i = 0, l = 0, u = 0, m = 0;
+  switch (BuiltinID) {
+  default: return false;
+  // These intrinsics take an unsigned 5 bit immediate and a signed 12 bit immediate.
+  case LoongArch::BI__builtin_loongarch_cacop:
+  case LoongArch::BI__builtin_loongarch_dcacop:
+    return SemaBuiltinConstantArgRange(TheCall, 0, 0, 31) ||
+           SemaBuiltinConstantArgRange(TheCall, 2, -2048, 2047);
+  // These intrinsics take an unsigned 14 bit immediate.
+  case LoongArch::BI__builtin_loongarch_csrrd:
+  case LoongArch::BI__builtin_loongarch_dcsrrd: i = 0; l = 0; u = 16383; break;
+  case LoongArch::BI__builtin_loongarch_csrwr:
+  case LoongArch::BI__builtin_loongarch_dcsrwr: i = 1; l = 0; u = 16383; break;
+  case LoongArch::BI__builtin_loongarch_csrxchg:
+  case LoongArch::BI__builtin_loongarch_dcsrxchg: i = 2; l = 0; u = 16383; break;
+  // These intrinsics take an unsigned 15 bit immediate.
+  case LoongArch::BI__builtin_loongarch_dbar:
+  case LoongArch::BI__builtin_loongarch_ibar:
+  case LoongArch::BI__builtin_loongarch_syscall:
+  case LoongArch::BI__builtin_loongarch_break: i = 0; l = 0; u = 32767; break;
+  }
+
+  if (!m)
+    return SemaBuiltinConstantArgRange(TheCall, i, l, u);
+
+  return SemaBuiltinConstantArgRange(TheCall, i, l, u) ||
+         SemaBuiltinConstantArgMultiple(TheCall, i, m);
+}
+
 bool Sema::CheckSystemZBuiltinFunctionCall(unsigned BuiltinID,
                                            CallExpr *TheCall) {
   if (BuiltinID == SystemZ::BI__builtin_tabort) {
diff -uNr llvm-toolchain-14-14.0.6.orig/clang/test/CodeGen/builtins-loongarch-base.c llvm-toolchain-14-14.0.6/clang/test/CodeGen/builtins-loongarch-base.c
--- llvm-toolchain-14-14.0.6.orig/clang/test/CodeGen/builtins-loongarch-base.c	1970-01-01 08:00:00.000000000 +0800
+++ llvm-toolchain-14-14.0.6/clang/test/CodeGen/builtins-loongarch-base.c	2023-03-09 13:35:06.296283774 +0800
@@ -0,0 +1,417 @@
+// REQUIRES: loongarch-registered-target
+// RUN: %clang_cc1 -triple loongarch64-linux-gnu -emit-llvm %s -o - | FileCheck %s
+
+#include <larchintrin.h>
+
+typedef char i8;
+typedef unsigned char u8;
+typedef short i16;
+typedef unsigned short u16;
+typedef int i32;
+typedef unsigned int u32;
+
+#if __LONG_MAX__ == __LONG_LONG_MAX__
+typedef long int i64;
+typedef unsigned long int u64;
+#else
+typedef long long i64;
+typedef unsigned long long u64;
+#endif
+
+__drdtime_t drdtime;
+__rdtime_t rdtime;
+
+void cpucfg(){
+
+  u32 u32_r, u32_a;
+  // __cpucfg
+  // rd, rj
+  // unsigned int, unsigned int
+  u32_r= __builtin_loongarch_cpucfg(u32_a); // CHECK: call i32 @llvm.loongarch.cpucfg
+
+}
+
+void csrrd(){
+
+  u32 u32_r;
+  // __csrrd
+  // rd, csr_num
+  // unsigned int, uimm14_32
+  u32_r=__builtin_loongarch_csrrd(1); // CHECK: call i32 @llvm.loongarch.csrrd
+
+}
+
+void dcsrrd(){
+
+  u64 u64_r;
+  // __dcsrrd
+  // rd, csr_num
+  // unsigned long int, uimm14
+  u64_r=__builtin_loongarch_dcsrrd(1); // CHECK: call i64 @llvm.loongarch.dcsrrd
+
+}
+
+void csrwr(){
+
+  u32 u32_r, u32_a;
+  // __csrwr
+  // rd, csr_num
+  // unsigned int, uimm14_32
+  u32_r=__builtin_loongarch_csrwr(u32_a, 1); // CHECK: call i32 @llvm.loongarch.csrwr
+
+}
+
+void dcsrwr(){
+
+  u64 u64_r, u64_a;
+  // __dcsrwr
+  // rd, csr_num
+  // unsigned long int, uimm14
+  u64_r=__builtin_loongarch_dcsrwr(u64_a, 1); // CHECK: call i64 @llvm.loongarch.dcsrwr
+
+}
+
+void csrxchg(){
+
+  u32 u32_r, u32_a, u32_b;
+  // __csrxchg
+  // rd, rj, csr_num
+  // unsigned int, unsigned int, uimm14_32
+  u32_r=__builtin_loongarch_csrxchg(u32_a, u32_b, 1); // CHECK: call i32 @llvm.loongarch.csrxchg
+
+}
+
+void dcsrxchg(){
+
+  u64 u64_r, u64_a, u64_b;
+  // __dcsrxchg
+  // rd, rj, csr_num
+  // unsigned long int, unsigned long int, uimm14
+  u64_r=__builtin_loongarch_dcsrxchg(u64_a, u64_b, 1); // CHECK: call i64 @llvm.loongarch.dcsrxchg
+
+}
+
+void iocsrrd_b(){
+
+  u32 u32_a;
+  u8 u8_r;
+  // __iocsrrd_b
+  // rd, rj
+  // unsigned char, unsigned int
+  u8_r=__builtin_loongarch_iocsrrd_b(u32_a); // CHECK: call i32 @llvm.loongarch.iocsrrd.b
+
+}
+
+void iocsrrd_h(){
+
+  u32 u32_a;
+  u16 u16_r;
+  // __iocsrrd_h
+  // rd, rj
+  // unsigned short, unsigned int
+  u16_r=__builtin_loongarch_iocsrrd_h(u32_a); // CHECK: call i32 @llvm.loongarch.iocsrrd.h
+
+}
+
+void iocsrrd_w(){
+
+  u32 u32_r, u32_a;
+  // __iocsrrd_w
+  // rd, rj
+  // unsigned int, unsigned int
+  u32_r=__builtin_loongarch_iocsrrd_w(u32_a); // CHECK: call i32 @llvm.loongarch.iocsrrd.w
+
+}
+
+void iocsrrd_d(){
+
+  u32 u32_a;
+  u64 u64_r;
+  // __iocsrrd_d
+  // rd, rj
+  // unsigned long int, unsigned int
+  u64_r=__builtin_loongarch_iocsrrd_d(u32_a); // CHECK: call i64 @llvm.loongarch.iocsrrd.d
+
+}
+
+void iocsrwr_b(){
+
+  u32 u32_a;
+  u8 u8_a;
+  // __iocsrwr_b
+  // rd, rj
+  // unsigned char, unsigned int
+  __builtin_loongarch_iocsrwr_b(u8_a, u32_a); // CHECK: void @llvm.loongarch.iocsrwr.b
+
+}
+
+void iocsrwr_h(){
+
+  u32 u32_a;
+  u16 u16_a;
+  // __iocsrwr_h
+  // rd, rj
+  // unsigned short, unsigned int
+  __builtin_loongarch_iocsrwr_h(u16_a, u32_a); // CHECK: void @llvm.loongarch.iocsrwr.h
+
+}
+
+void iocsrwr_w(){
+
+  u32 u32_a, u32_b;
+  // __iocsrwr_w
+  // rd, rj
+  // unsigned int, unsigned int
+  __builtin_loongarch_iocsrwr_w(u32_a, u32_b); // CHECK: void @llvm.loongarch.iocsrwr.w
+
+}
+
+void iocsrwr_d(){
+
+  u32 u32_a;
+  u64 u64_a;
+  // __iocsrwr_d
+  // rd, rj
+  // unsigned long int, unsigned int
+  __builtin_loongarch_iocsrwr_d(u64_a, u32_a); // CHECK: void @llvm.loongarch.iocsrwr.d
+
+}
+
+void cacop(){
+
+  i32 i32_a;
+  // __cacop
+  // op, rj, si12
+  // uimm5, unsigned int, simm12
+  __builtin_loongarch_cacop(1, i32_a, 2); // CHECK: void @llvm.loongarch.cacop
+
+}
+
+void dcacop(){
+
+  i64 i64_a;
+  // __dcacop
+  // op, rj, si12
+  // uimm5, unsigned long int, simm12
+  __builtin_loongarch_dcacop(1, i64_a, 2); // CHECK: void @llvm.loongarch.dcacop
+
+}
+
+void rdtime_d(){
+
+  drdtime= __builtin_loongarch_rdtime_d(); // CHECK: call { i64, i64 } asm sideeffect "rdtime.d\09$0,$1\0A\09", "=&r,=&r"()
+
+}
+
+void rdtimeh_w(){
+
+  rdtime= __builtin_loongarch_rdtimeh_w(); // CHECK: call { i32, i32 } asm sideeffect "rdtimeh.w\09$0,$1\0A\09", "=&r,=&r"()
+
+}
+
+void rdtimel_w(){
+
+  rdtime= __builtin_loongarch_rdtimel_w(); // CHECK: call { i32, i32 } asm sideeffect "rdtimel.w\09$0,$1\0A\09", "=&r,=&r"()
+
+}
+
+void crc_w_b_w(){
+
+  i32 i32_r, i32_a;
+  i8 i8_a;
+  // __crc_w_b_w
+  // rd, rj, rk
+  // int, char, int
+  i32_r=__builtin_loongarch_crc_w_b_w(i8_a, i32_a); // CHECK: call i32 @llvm.loongarch.crc.w.b.w
+
+}
+
+void crc_w_h_w(){
+
+  i32 i32_r, i32_a;
+  i16 i16_a;
+  // __crc_w_h_w
+  // rd, rj, rk
+  // int, short, int
+  i32_r=__builtin_loongarch_crc_w_h_w(i16_a, i32_a); // CHECK: call i32 @llvm.loongarch.crc.w.h.w
+
+}
+
+void crc_w_w_w(){
+
+  i32 i32_r, i32_a, i32_b;
+  // __crc_w_w_w
+  // rd, rj, rk
+  // int, int, int
+  i32_r=__builtin_loongarch_crc_w_w_w(i32_a, i32_b); // CHECK: call i32 @llvm.loongarch.crc.w.w.w
+
+}
+
+void crc_w_d_w(){
+
+  i32 i32_r, i32_a;
+  i64 i64_a;
+  // __crc_w_d_w
+  // rd, rj, rk
+  // int, long int, int
+  i32_r=__builtin_loongarch_crc_w_d_w(i64_a, i32_a); // CHECK: call i32 @llvm.loongarch.crc.w.d.w
+
+}
+
+void crcc_w_b_w(){
+
+  i32 i32_r, i32_a;
+  i8 i8_a;
+  // __crcc_w_b_w
+  // rd, rj, rk
+  // int, char, int
+  i32_r=__builtin_loongarch_crcc_w_b_w(i8_a, i32_a); // CHECK: call i32 @llvm.loongarch.crcc.w.b.w
+
+}
+
+void crcc_w_h_w(){
+
+  i32 i32_r, i32_a;
+  i16 i16_a;
+  // __crcc_w_h_w
+  // rd, rj, rk
+  // int, short, int
+  i32_r=__builtin_loongarch_crcc_w_h_w(i16_a, i32_a); // CHECK: call i32 @llvm.loongarch.crcc.w.h.w
+
+}
+
+void crcc_w_w_w(){
+
+  i32 i32_r, i32_a, i32_b;
+  // __crcc_w_w_w
+  // rd, rj, rk
+  // int, int, int
+  i32_r=__builtin_loongarch_crcc_w_w_w(i32_a, i32_b); // CHECK: call i32 @llvm.loongarch.crcc.w.w.w
+
+}
+
+void crcc_w_d_w(){
+
+  i32 i32_r, i32_a;
+  i64 i64_a;
+  // __crcc_w_d_w
+  // rd, rj, rk
+  // int, long int, int
+  i32_r=__builtin_loongarch_crcc_w_d_w(i64_a, i32_a); // CHECK: call i32 @llvm.loongarch.crcc.w.d.w
+
+}
+
+void tlbclr(){
+
+  // __tlbclr
+  __builtin_loongarch_tlbclr(); // CHECK: call void @llvm.loongarch.tlbclr
+
+}
+
+void tlbflush(){
+
+  // __tlbflush
+  __builtin_loongarch_tlbflush(); // CHECK: call void @llvm.loongarch.tlbflush
+
+}
+
+void tlbfill(){
+
+  // __tlbfill
+  __builtin_loongarch_tlbfill(); // CHECK: call void @llvm.loongarch.tlbfill 
+
+}
+
+void tlbrd(){
+
+  // __tlbrd
+  __builtin_loongarch_tlbrd(); // CHECK: call void @llvm.loongarch.tlbrd
+
+}
+
+void tlbwr(){
+
+  // __tlbwr
+  __builtin_loongarch_tlbwr(); // CHECK: call void @llvm.loongarch.tlbwr
+
+}
+
+void tlbsrch(){
+
+  // __tlbsrch
+  __builtin_loongarch_tlbsrch(); // CHECK: call void @llvm.loongarch.tlbsrch
+
+}
+
+void syscall(){
+
+  // __syscall
+  // Code
+  // uimm15
+  __builtin_loongarch_syscall(1); // CHECK: call void @llvm.loongarch.syscall
+
+}
+
+void break_builtin(){
+
+  // __break
+  // Code
+  // uimm15
+  __builtin_loongarch_break(1); // CHECK: call void @llvm.loongarch.break
+
+}
+
+void asrtle_d(){
+
+  i64 i64_a, i64_b;
+  // __asrtle_d
+  // rj, rk
+  // long int, long int
+  __builtin_loongarch_asrtle_d(i64_a, i64_b); // CHECK: call void @llvm.loongarch.asrtle.d
+
+}
+
+void asrtgt_d(){
+
+  i64 i64_a, i64_b;
+  // __asrtgt_d
+  // rj, rk
+  // long int, long int
+  __builtin_loongarch_asrtgt_d(i64_a, i64_b); // CHECK: call void @llvm.loongarch.asrtgt.d
+
+}
+
+void dbar(){
+
+  // __dbar
+  // hint
+  // uimm15
+  __builtin_loongarch_dbar(0); // CHECK: call void @llvm.loongarch.dbar
+
+}
+
+void ibar(){
+
+  // __ibar
+  // hint
+  // uimm15
+  __builtin_loongarch_ibar(0); // CHECK: call void @llvm.loongarch.ibar
+
+}
+
+void movfcsr2gr(){
+
+  u32 u32_r;
+  // __movfcsr2gr
+  u32_r=__movfcsr2gr(0); // CHECK: call i32 asm sideeffect "movfcsr2gr $0, $$fcsr0", "=&r"()
+
+}
+
+
+void movgr2fcsr() {
+
+  u32 u32_a;
+  // __movgr2fcsr
+  __movgr2fcsr(0, u32_a); // CHECK: call void asm sideeffect "movgr2fcsr $$fcsr0, $0", "r"(i32 %0)
+
+}
diff -uNr llvm-toolchain-14-14.0.6.orig/clang/test/CodeGen/loongarch-inline-asm-modifiers.c llvm-toolchain-14-14.0.6/clang/test/CodeGen/loongarch-inline-asm-modifiers.c
--- llvm-toolchain-14-14.0.6.orig/clang/test/CodeGen/loongarch-inline-asm-modifiers.c	1970-01-01 08:00:00.000000000 +0800
+++ llvm-toolchain-14-14.0.6/clang/test/CodeGen/loongarch-inline-asm-modifiers.c	2023-03-09 13:35:06.296283774 +0800
@@ -0,0 +1,40 @@
+// RUN: %clang -target loongarch64-unknown-linux-gnu -S -o - -emit-llvm %s \
+// RUN: | FileCheck %s
+
+// This checks that the frontend will accept inline asm operand modifiers
+
+int printf(const char*, ...);
+
+typedef long long v2i64 __attribute__ ((vector_size(16), aligned(16)));
+typedef long long v4i64 __attribute__ ((vector_size(32), aligned(32)));
+
+  // CHECK: %{{[0-9]+}} = call i32 asm ".set noreorder;\0Ald.w    $0,$1;\0A.set reorder;\0A", "=r,*m"(i32* getelementptr inbounds ([8 x i32], [8 x i32]* @b, i64 {{[0-9]+}}, i64 {{[0-9]+}})) #2,
+  // CHECK: %{{[0-9]+}} = call i32 asm "ld.w    $0,${1:D};\0A", "=r,*m"(i32* getelementptr inbounds ([8 x i32], [8 x i32]* @b, i64 {{[0-9]+}}, i64 {{[0-9]+}})) #2,
+int b[8] = {0,1,2,3,4,5,6,7};
+int  main()
+{
+  int i;
+  v2i64 v2i64_r;
+  v4i64 v4i64_r;
+
+  // The first word. Notice, no 'D'
+  {asm (
+  ".set noreorder;\n"
+  "ld.w    %0,%1;\n"
+  ".set reorder;\n"
+  : "=r" (i)
+  : "m" (*(b+4)));}
+
+  printf("%d\n",i);
+
+  // The second word
+  {asm (
+  "ld.w    %0,%D1;\n"
+  : "=r" (i)
+  : "m" (*(b+4))
+  );}
+
+  printf("%d\n",i);
+
+  return 1;
+}
diff -uNr llvm-toolchain-14-14.0.6.orig/clang/test/CodeGen/loongarch-inline-asm.c llvm-toolchain-14-14.0.6/clang/test/CodeGen/loongarch-inline-asm.c
--- llvm-toolchain-14-14.0.6.orig/clang/test/CodeGen/loongarch-inline-asm.c	1970-01-01 08:00:00.000000000 +0800
+++ llvm-toolchain-14-14.0.6/clang/test/CodeGen/loongarch-inline-asm.c	2023-03-09 13:35:06.296283774 +0800
@@ -0,0 +1,31 @@
+// REQUIRES: loongarch-registered-target
+// RUN: %clang_cc1 -triple loongarch64-linux-gnu -emit-llvm -o - %s | FileCheck %s
+
+int data;
+
+void m () {
+  asm("ld.w $r1, %0" :: "m"(data));
+  // CHECK: call void asm sideeffect "ld.w $$r1, $0", "*m"(i32* @data)
+}
+
+void ZC () {
+  asm("ll.w $r1, %0" :: "ZC"(data));
+  // CHECK: call void asm sideeffect "ll.w $$r1, $0", "*^ZC"(i32* @data)
+}
+
+void ZB () {
+  asm("amadd_db.w $zero, $r1, %0" :: "ZB"(data));
+  // CHECK: call void asm sideeffect "amadd_db.w $$zero, $$r1, $0", "*^ZB"(i32* @data)
+}
+
+void R () {
+  asm("ld.w $r1, %0" :: "R"(data));
+  // CHECK: call void asm sideeffect "ld.w $$r1, $0", "*R"(i32* @data)
+}
+
+int *p;
+void preld () {
+  asm("preld 0, %0, 2" :: "r"(p));
+  // CHECK: %0 = load i32*, i32** @p, align 8
+  // CHECK: call void asm sideeffect "preld 0, $0, 2", "r"(i32* %0)
+}
diff -uNr llvm-toolchain-14-14.0.6.orig/clang/test/CodeGen/struct-128.cpp llvm-toolchain-14-14.0.6/clang/test/CodeGen/struct-128.cpp
--- llvm-toolchain-14-14.0.6.orig/clang/test/CodeGen/struct-128.cpp	1970-01-01 08:00:00.000000000 +0800
+++ llvm-toolchain-14-14.0.6/clang/test/CodeGen/struct-128.cpp	2023-03-09 13:35:06.296283774 +0800
@@ -0,0 +1,23 @@
+// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
+// RUN: %clang_cc1  -triple loongarch64-linux-gnu -emit-llvm %s -o - | FileCheck %s
+
+//Check that a struct return value with a certain condition on loongarch64 is returned by address
+
+typedef struct _B {
+    int *ptr;
+    int index;
+} B;
+
+typedef struct _A : B {
+    float dd;
+} A;
+
+// CHECK-LABEL: void @_Z3foov(%struct._A*
+// CHECK-NEXT:  entry:
+// CHECK-NEXT:    ret void
+//
+A foo()
+{
+    A a;
+    return a;
+}
diff -uNr llvm-toolchain-14-14.0.6.orig/clang/test/CodeGen/struct-packed-128.cpp llvm-toolchain-14-14.0.6/clang/test/CodeGen/struct-packed-128.cpp
--- llvm-toolchain-14-14.0.6.orig/clang/test/CodeGen/struct-packed-128.cpp	1970-01-01 08:00:00.000000000 +0800
+++ llvm-toolchain-14-14.0.6/clang/test/CodeGen/struct-packed-128.cpp	2023-03-09 13:35:06.296283774 +0800
@@ -0,0 +1,23 @@
+// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
+// RUN: %clang_cc1  -triple loongarch64-linux-gnu -emit-llvm %s -o - | FileCheck %s
+typedef struct _B {
+    int *ptr;
+    int index;
+} __attribute__((packed)) B;
+
+typedef struct _A : B {
+    float dd;
+} A;
+
+// CHECK-LABEL: [2 x i64] @_Z3foov(
+// CHECK-NEXT:  entry:
+// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT__A:%.*]], align 4
+// CHECK-NEXT:    [[TMP0:%.*]] = bitcast %struct._A* [[RETVAL]] to [2 x i64]*
+// CHECK-NEXT:    [[TMP1:%.*]] = load [2 x i64], [2 x i64]* [[TMP0]], align 4
+// CHECK-NEXT:    ret [2 x i64] [[TMP1]]
+//
+A foo()
+{
+    A a;
+    return a;
+}
diff -uNr llvm-toolchain-14-14.0.6.orig/clang/test/CodeGen/struct-private-128.cpp llvm-toolchain-14-14.0.6/clang/test/CodeGen/struct-private-128.cpp
--- llvm-toolchain-14-14.0.6.orig/clang/test/CodeGen/struct-private-128.cpp	1970-01-01 08:00:00.000000000 +0800
+++ llvm-toolchain-14-14.0.6/clang/test/CodeGen/struct-private-128.cpp	2023-03-09 13:35:06.296283774 +0800
@@ -0,0 +1,24 @@
+// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
+// RUN: %clang_cc1  -triple loongarch64-linux-gnu -emit-llvm %s -o - | FileCheck %s
+typedef struct _B {
+    int *ptr;
+private:
+    int index;
+} B;
+
+typedef struct _A : B {
+    float dd;
+} A;
+
+// CHECK-LABEL: @_Z3foov(
+// CHECK-NEXT:  entry:
+// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT__A:%.*]], align 8
+// CHECK-NEXT:    [[TMP0:%.*]] = bitcast %struct._A* [[RETVAL]] to [2 x i64]*
+// CHECK-NEXT:    [[TMP1:%.*]] = load [2 x i64], [2 x i64]* [[TMP0]], align 8
+// CHECK-NEXT:    ret [2 x i64] [[TMP1]]
+//
+A foo()
+{
+    A a;
+    return a;
+}
diff -uNr llvm-toolchain-14-14.0.6.orig/clang/test/CodeGen/struct-static.cpp llvm-toolchain-14-14.0.6/clang/test/CodeGen/struct-static.cpp
--- llvm-toolchain-14-14.0.6.orig/clang/test/CodeGen/struct-static.cpp	1970-01-01 08:00:00.000000000 +0800
+++ llvm-toolchain-14-14.0.6/clang/test/CodeGen/struct-static.cpp	2023-03-09 13:35:06.296283774 +0800
@@ -0,0 +1,25 @@
+// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
+// RUN: %clang_cc1  -triple loongarch64-linux-gnu -emit-llvm %s -o - | FileCheck %s
+
+typedef struct _B {
+ static long ptr;
+ int index;
+} B;
+
+typedef struct _A : B {
+ float dd;
+} A;
+
+// CHECK-LABEL: @_Z3foov(
+// CHECK-NEXT:  entry:
+// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT__A:%.*]], align 4
+// CHECK-NEXT:    [[TMP0:%.*]] = bitcast %struct._A* [[RETVAL]] to i64*
+// CHECK-NEXT:    [[TMP1:%.*]] = load i64, i64* [[TMP0]], align 4
+// CHECK-NEXT:    ret i64 [[TMP1]]
+//
+A foo()
+{
+ A a;
+ return a;
+}
+
diff -uNr llvm-toolchain-14-14.0.6.orig/clang/test/Driver/loongarch-abi-fpu.c llvm-toolchain-14-14.0.6/clang/test/Driver/loongarch-abi-fpu.c
--- llvm-toolchain-14-14.0.6.orig/clang/test/Driver/loongarch-abi-fpu.c	1970-01-01 08:00:00.000000000 +0800
+++ llvm-toolchain-14-14.0.6/clang/test/Driver/loongarch-abi-fpu.c	2023-03-09 13:35:06.296283774 +0800
@@ -0,0 +1,26 @@
+/// Check passing -mabi=<ABIName> and -mfpu=<FPU> options to the backend.
+
+// RUN: %clang -target loongarch64 %s -mabi=lp64s -mfpu=none -### 2>&1 \
+// RUN:   | FileCheck --check-prefix=FEATURE-NF-ND %s
+// RUN: %clang -target loongarch64 %s -mabi=lp64s -mfpu=32 -### 2>&1 \
+// RUN:   | FileCheck --check-prefix=FEATURE-F %s
+// RUN: %clang -target loongarch64 %s -mabi=lp64s -mfpu=64 -### 2>&1 \
+// RUN:   | FileCheck --check-prefix=FEATURE-D %s
+// RUN: %clang -target loongarch64 %s -mabi=lp64f -mfpu=none -### 2>&1 \
+// RUN:   | FileCheck --check-prefix=ERRLP64F-WITH-FPUNONE %s
+// RUN: %clang -target loongarch64 %s -mabi=lp64f -mfpu=32 -### 2>&1 \
+// RUN:   | FileCheck --check-prefix=FEATURE-F %s
+// RUN: %clang -target loongarch64 %s -mabi=lp64f -mfpu=64 -### 2>&1 \
+// RUN:   | FileCheck --check-prefix=FEATURE-D %s
+// RUN: %clang -target loongarch64 %s -mabi=lp64d -mfpu=none -### 2>&1 \
+// RUN:   | FileCheck --check-prefix=ERRLP64D-ONLY-FPU64 %s
+// RUN: %clang -target loongarch64 %s -mabi=lp64d -mfpu=32 -### 2>&1 \
+// RUN:   | FileCheck --check-prefix=ERRLP64D-ONLY-FPU64 %s
+// RUN: %clang -target loongarch64 %s -mabi=lp64d -mfpu=64 -### 2>&1 \
+// RUN:   | FileCheck --check-prefix=FEATURE-D %s
+
+// FEATURE-D: "-target-feature" "+d"
+// FEATURE-F: "-target-feature" "+f"
+// FEATURE-NF-ND: "-target-feature" "-f" "-target-feature" "-d"
+// ERRLP64D-ONLY-FPU64: error: option 'lp64d' cannot be specified without '-mfpu=64'
+// ERRLP64F-WITH-FPUNONE: error: option 'lp64f' cannot be specified with '-mfpu=none'
diff -uNr llvm-toolchain-14-14.0.6.orig/clang/test/Driver/loongarch-double-single-soft.c llvm-toolchain-14-14.0.6/clang/test/Driver/loongarch-double-single-soft.c
--- llvm-toolchain-14-14.0.6.orig/clang/test/Driver/loongarch-double-single-soft.c	1970-01-01 08:00:00.000000000 +0800
+++ llvm-toolchain-14-14.0.6/clang/test/Driver/loongarch-double-single-soft.c	2023-03-09 13:35:06.296283774 +0800
@@ -0,0 +1,12 @@
+// Check passing -m*-float options to the backend.
+
+// RUN: %clang -target loongarch64 %s -mdouble-float -### 2>&1 \
+// RUN:   | FileCheck --check-prefix=CHECK-DOUBLE %s
+// RUN: %clang -target loongarch64 %s -msingle-float -### 2>&1 \
+// RUN:   | FileCheck --check-prefix=CHECK-SINGLE %s
+// RUN: %clang -target loongarch64 %s -msoft-float -### 2>&1 \
+// RUN:   | FileCheck --check-prefix=CHECK-SOFT %s
+
+// CHECK-DOUBLE: "-target-feature" "+d" "-target-abi" "lp64d"
+// CHECK-SINGLE: "-target-feature" "+f" "-target-abi" "lp64f"
+// CHECK-SOFT: "-target-feature" "-f" "-target-feature" "-d" "-target-abi" "lp64s"
diff -uNr llvm-toolchain-14-14.0.6.orig/clang/test/Driver/loongarch-mabi.c llvm-toolchain-14-14.0.6/clang/test/Driver/loongarch-mabi.c
--- llvm-toolchain-14-14.0.6.orig/clang/test/Driver/loongarch-mabi.c	1970-01-01 08:00:00.000000000 +0800
+++ llvm-toolchain-14-14.0.6/clang/test/Driver/loongarch-mabi.c	2023-03-09 13:35:06.296283774 +0800
@@ -0,0 +1,22 @@
+// Check passing -mabi=<ABIName> options to the backend.
+
+// check default ABI for loongarch64
+// RUN: %clang -target loongarch64 %s -### 2>&1 \
+// RUN:   | FileCheck --check-prefix=CHECK-LP64D %s
+// check -mabi=lp64d option for loongarch64
+// RUN: %clang -target loongarch64 %s -mabi=lp64d -### 2>&1 \
+// RUN:   | FileCheck --check-prefix=CHECK-LP64D %s
+// check -mabi=lp64f option for loongarch64
+// RUN: %clang -target loongarch64 %s -mabi=lp64f -### 2>&1 \
+// RUN:   | FileCheck --check-prefix=CHECK-LP64F %s
+// check -mabi=lp64s option for loongarch64
+// RUN: %clang -target loongarch64 %s -mabi=lp64s -### 2>&1 \
+// RUN:   | FileCheck --check-prefix=CHECK-LP64S %s
+// check invalid -mabi=x option for loongarch64
+// RUN: not %clang -target loongarch64 %s -mabi=x 2>&1 \
+// RUN:   | FileCheck --check-prefix=CHECK-X %s
+
+// CHECK-LP64D: "-target-abi" "lp64d"
+// CHECK-LP64F: "-target-abi" "lp64f"
+// CHECK-LP64S: "-target-abi" "lp64s"
+// CHECK-X: error: unknown target ABI 'x'
diff -uNr llvm-toolchain-14-14.0.6.orig/clang/test/Driver/loongarch-mfpu.c llvm-toolchain-14-14.0.6/clang/test/Driver/loongarch-mfpu.c
--- llvm-toolchain-14-14.0.6.orig/clang/test/Driver/loongarch-mfpu.c	1970-01-01 08:00:00.000000000 +0800
+++ llvm-toolchain-14-14.0.6/clang/test/Driver/loongarch-mfpu.c	2023-03-09 13:35:06.296283774 +0800
@@ -0,0 +1,21 @@
+// Check passing -mfpu=<FPU> options to the backend.
+
+// check default feature for loongarch64
+// RUN: %clang -target loongarch64 %s -### 2>&1 \
+// RUN:   | FileCheck --check-prefix=FEATURE-D %s
+// check -mfpu=64 option for loongarch64
+// RUN: %clang -target loongarch64 %s -mfpu=64 -### 2>&1 \
+// RUN:   | FileCheck --check-prefix=FEATURE-D %s
+// check -mfpu=32 option for loongarch64
+// RUN: %clang -target loongarch64 %s -mfpu=32 -### 2>&1 \
+// RUN:   | FileCheck --check-prefix=ERRLP64D-ONLY-FPU64 %s
+// check -mfpu=none option for loongarch64
+// RUN: %clang -target loongarch64 %s -mfpu=none -### 2>&1 \
+// RUN:   | FileCheck --check-prefix=ERRLP64D-ONLY-FPU64 %s
+// check -mfpu=x option for loongarch64
+// RUN: %clang -target loongarch64 %s -mfpu=x -### 2>&1 \
+// RUN:   | FileCheck --check-prefix=INVALID-FPU %s
+
+// FEATURE-D: "-target-feature" "+d"
+// INVALID-FPU: error: invalid loongarch FPU value 'x'. Please specify FPU = 64,32 or none
+// ERRLP64D-ONLY-FPU64: error: option 'lp64d' cannot be specified without '-mfpu=64'
diff -uNr llvm-toolchain-14-14.0.6.orig/llvm/CMakeLists.txt.orig llvm-toolchain-14-14.0.6/llvm/CMakeLists.txt.orig
--- llvm-toolchain-14-14.0.6.orig/llvm/CMakeLists.txt.orig	2021-09-21 16:43:12.000000000 +0800
+++ llvm-toolchain-14-14.0.6/llvm/CMakeLists.txt.orig	1970-01-01 08:00:00.000000000 +0800
@@ -1,1194 +0,0 @@
-# See docs/CMake.html for instructions about how to build LLVM with CMake.
-
-cmake_minimum_required(VERSION 3.13.4)
-
-# CMP0116: Ninja generators transform `DEPFILE`s from `add_custom_command()`
-# New in CMake 3.20. https://cmake.org/cmake/help/latest/policy/CMP0116.html
-if(POLICY CMP0116)
-  cmake_policy(SET CMP0116 OLD)
-endif()
-
-set(CMAKE_BUILD_WITH_INSTALL_NAME_DIR ON)
-
-if(NOT DEFINED LLVM_VERSION_MAJOR)
-  set(LLVM_VERSION_MAJOR 14)
-endif()
-if(NOT DEFINED LLVM_VERSION_MINOR)
-  set(LLVM_VERSION_MINOR 0)
-endif()
-if(NOT DEFINED LLVM_VERSION_PATCH)
-  set(LLVM_VERSION_PATCH 0)
-endif()
-if(NOT DEFINED LLVM_VERSION_SUFFIX)
-  set(LLVM_VERSION_SUFFIX git)
-endif()
-
-if (NOT PACKAGE_VERSION)
-  set(PACKAGE_VERSION
-    "${LLVM_VERSION_MAJOR}.${LLVM_VERSION_MINOR}.${LLVM_VERSION_PATCH}${LLVM_VERSION_SUFFIX}")
-endif()
-
-if ((CMAKE_GENERATOR MATCHES "Visual Studio") AND (CMAKE_GENERATOR_TOOLSET STREQUAL ""))
-  message(WARNING "Visual Studio generators use the x86 host compiler by "
-                  "default, even for 64-bit targets. This can result in linker "
-                  "instability and out of memory errors. To use the 64-bit "
-                  "host compiler, pass -Thost=x64 on the CMake command line.")
-endif()
-
-if (CMAKE_GENERATOR STREQUAL "Xcode" AND NOT CMAKE_OSX_ARCHITECTURES)
-  # Some CMake features like object libraries get confused if you don't
-  # explicitly specify an architecture setting with the Xcode generator.
-  set(CMAKE_OSX_ARCHITECTURES "x86_64")
-endif()
-
-project(LLVM
-  VERSION ${LLVM_VERSION_MAJOR}.${LLVM_VERSION_MINOR}.${LLVM_VERSION_PATCH}
-  LANGUAGES C CXX ASM)
-
-set(CMAKE_CXX_STANDARD 14 CACHE STRING "C++ standard to conform to")
-set(CMAKE_CXX_STANDARD_REQUIRED YES)
-if (CYGWIN)
-  # Cygwin is a bit stricter and lack things like 'strdup', 'stricmp', etc in
-  # c++xx mode.
-  set(CMAKE_CXX_EXTENSIONS YES)
-else()
-  set(CMAKE_CXX_EXTENSIONS NO)
-endif()
-
-if (NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
-  message(STATUS "No build type selected, default to Debug")
-  set(CMAKE_BUILD_TYPE "Debug" CACHE STRING "Build type (default Debug)" FORCE)
-endif()
-
-# Side-by-side subprojects layout: automatically set the
-# LLVM_EXTERNAL_${project}_SOURCE_DIR using LLVM_ALL_PROJECTS
-# This allows an easy way of setting up a build directory for llvm and another
-# one for llvm+clang+... using the same sources.
-set(LLVM_ALL_PROJECTS "clang;clang-tools-extra;compiler-rt;cross-project-tests;libc;libclc;libcxx;libcxxabi;libunwind;lld;lldb;mlir;openmp;parallel-libs;polly;pstl")
-# The flang project is not yet part of "all" projects (see C++ requirements)
-set(LLVM_EXTRA_PROJECTS "flang")
-# List of all known projects in the mono repo
-set(LLVM_KNOWN_PROJECTS "${LLVM_ALL_PROJECTS};${LLVM_EXTRA_PROJECTS}")
-set(LLVM_ENABLE_PROJECTS "" CACHE STRING
-	"Semicolon-separated list of projects to build (${LLVM_KNOWN_PROJECTS}), or \"all\".")
-
-option(LLVM_CHECK_ENABLED_PROJECTS "Whether to check LLVM_ENABLE_PROJECTS" ON)
-if (LLVM_CHECK_ENABLED_PROJECTS)
-  foreach(proj ${LLVM_ENABLE_PROJECTS})
-    if (NOT proj STREQUAL "all" AND NOT proj STREQUAL "llvm" AND NOT "${proj}" IN_LIST LLVM_KNOWN_PROJECTS)
-       MESSAGE(FATAL_ERROR "${proj} isn't a known project: ${LLVM_KNOWN_PROJECTS}")
-    endif()
-  endforeach()
-endif()
-
-if( LLVM_ENABLE_PROJECTS STREQUAL "all" )
-  set( LLVM_ENABLE_PROJECTS ${LLVM_ALL_PROJECTS})
-endif()
-
-if ("flang" IN_LIST LLVM_ENABLE_PROJECTS)
-  if (NOT "mlir" IN_LIST LLVM_ENABLE_PROJECTS)
-    message(STATUS "Enabling MLIR as a dependency to flang")
-    list(APPEND LLVM_ENABLE_PROJECTS "mlir")
-  endif()
-
-  if (NOT "clang" IN_LIST LLVM_ENABLE_PROJECTS)
-    message(FATAL_ERROR "Clang is not enabled, but is required for the Flang driver")
-  endif()
-endif()
-
-# LLVM_ENABLE_PROJECTS_USED is `ON` if the user has ever used the
-# `LLVM_ENABLE_PROJECTS` CMake cache variable.  This exists for
-# several reasons:
-#
-# * As an indicator that the `LLVM_ENABLE_PROJECTS` list is now the single
-# source of truth for which projects to build. This means we will ignore user
-# supplied `LLVM_TOOL_<project>_BUILD` CMake cache variables and overwrite
-# them.
-#
-# * The case where the user previously had `LLVM_ENABLE_PROJECTS` set to a
-# non-empty list but now the user wishes to disable building all other projects
-# by setting `LLVM_ENABLE_PROJECTS` to an empty string. In that case we still
-# need to set the `LLVM_TOOL_${upper_proj}_BUILD` variables so that we disable
-# building all the projects that were previously enabled.
-set(LLVM_ENABLE_PROJECTS_USED OFF CACHE BOOL "")
-mark_as_advanced(LLVM_ENABLE_PROJECTS_USED)
-
-if (LLVM_ENABLE_PROJECTS_USED OR NOT LLVM_ENABLE_PROJECTS STREQUAL "")
-  set(LLVM_ENABLE_PROJECTS_USED ON CACHE BOOL "" FORCE)
-  foreach(proj ${LLVM_KNOWN_PROJECTS} ${LLVM_EXTERNAL_PROJECTS})
-    string(TOUPPER "${proj}" upper_proj)
-    string(REGEX REPLACE "-" "_" upper_proj ${upper_proj})
-    if ("${proj}" IN_LIST LLVM_ENABLE_PROJECTS)
-      message(STATUS "${proj} project is enabled")
-      set(SHOULD_ENABLE_PROJECT TRUE)
-      set(PROJ_DIR "${CMAKE_CURRENT_SOURCE_DIR}/../${proj}")
-      if(NOT EXISTS "${PROJ_DIR}" OR NOT IS_DIRECTORY "${PROJ_DIR}")
-        message(FATAL_ERROR "LLVM_ENABLE_PROJECTS requests ${proj} but directory not found: ${PROJ_DIR}")
-      endif()
-      if( LLVM_EXTERNAL_${upper_proj}_SOURCE_DIR STREQUAL "" )
-        set(LLVM_EXTERNAL_${upper_proj}_SOURCE_DIR "${CMAKE_CURRENT_SOURCE_DIR}/../${proj}" CACHE PATH "" FORCE)
-      else()
-        set(LLVM_EXTERNAL_${upper_proj}_SOURCE_DIR "${CMAKE_CURRENT_SOURCE_DIR}/../${proj}" CACHE PATH "")
-      endif()
-    elseif ("${proj}" IN_LIST LLVM_EXTERNAL_PROJECTS)
-      message(STATUS "${proj} project is enabled")
-      set(SHOULD_ENABLE_PROJECT TRUE)
-    else()
-      message(STATUS "${proj} project is disabled")
-      set(SHOULD_ENABLE_PROJECT FALSE)
-    endif()
-    # Force `LLVM_TOOL_${upper_proj}_BUILD` variables to have values that
-    # corresponds with `LLVM_ENABLE_PROJECTS`. This prevents the user setting
-    # `LLVM_TOOL_${upper_proj}_BUILD` variables externally. At some point
-    # we should deprecate allowing users to set these variables by turning them
-    # into normal CMake variables rather than cache variables.
-    set(LLVM_TOOL_${upper_proj}_BUILD
-      ${SHOULD_ENABLE_PROJECT}
-      CACHE
-      BOOL "Whether to build ${upper_proj} as part of LLVM" FORCE
-    )
-  endforeach()
-endif()
-unset(SHOULD_ENABLE_PROJECT)
-
-# Build llvm with ccache if the package is present
-set(LLVM_CCACHE_BUILD OFF CACHE BOOL "Set to ON for a ccache enabled build")
-if(LLVM_CCACHE_BUILD)
-  find_program(CCACHE_PROGRAM ccache)
-  if(CCACHE_PROGRAM)
-      set(LLVM_CCACHE_MAXSIZE "" CACHE STRING "Size of ccache")
-      set(LLVM_CCACHE_DIR "" CACHE STRING "Directory to keep ccached data")
-      set(LLVM_CCACHE_PARAMS "CCACHE_CPP2=yes CCACHE_HASHDIR=yes"
-          CACHE STRING "Parameters to pass through to ccache")
-
-      set(CCACHE_PROGRAM "${LLVM_CCACHE_PARAMS} ${CCACHE_PROGRAM}")
-      if (LLVM_CCACHE_MAXSIZE)
-        set(CCACHE_PROGRAM "CCACHE_MAXSIZE=${LLVM_CCACHE_MAXSIZE} ${CCACHE_PROGRAM}")
-      endif()
-      if (LLVM_CCACHE_DIR)
-        set(CCACHE_PROGRAM "CCACHE_DIR=${LLVM_CCACHE_DIR} ${CCACHE_PROGRAM}")
-      endif()
-      set_property(GLOBAL PROPERTY RULE_LAUNCH_COMPILE ${CCACHE_PROGRAM})
-  else()
-    message(FATAL_ERROR "Unable to find the program ccache. Set LLVM_CCACHE_BUILD to OFF")
-  endif()
-endif()
-
-option(LLVM_DEPENDENCY_DEBUGGING "Dependency debugging mode to verify correctly expressed library dependencies (Darwin only)" OFF)
-
-# Some features of the LLVM build may be disallowed when dependency debugging is
-# enabled. In particular you cannot use ccache because we want to force compile
-# operations to always happen.
-if(LLVM_DEPENDENCY_DEBUGGING)
-  if(NOT CMAKE_HOST_APPLE)
-    message(FATAL_ERROR "Dependency debugging is only currently supported on Darwin hosts.")
-  endif()
-  if(LLVM_CCACHE_BUILD)
-    message(FATAL_ERROR "Cannot enable dependency debugging while using ccache.")
-  endif()
-endif()
-
-option(LLVM_ENABLE_DAGISEL_COV "Debug: Prints tablegen patterns that were used for selecting" OFF)
-option(LLVM_ENABLE_GISEL_COV "Enable collection of GlobalISel rule coverage" OFF)
-if(LLVM_ENABLE_GISEL_COV)
-  set(LLVM_GISEL_COV_PREFIX "${CMAKE_BINARY_DIR}/gisel-coverage-" CACHE STRING "Provide a filename prefix to collect the GlobalISel rule coverage")
-endif()
-
-# Add path for custom modules
-set(CMAKE_MODULE_PATH
-  ${CMAKE_MODULE_PATH}
-  "${CMAKE_CURRENT_SOURCE_DIR}/cmake"
-  "${CMAKE_CURRENT_SOURCE_DIR}/cmake/modules"
-  )
-
-# Generate a CompilationDatabase (compile_commands.json file) for our build,
-# for use by clang_complete, YouCompleteMe, etc.
-set(CMAKE_EXPORT_COMPILE_COMMANDS 1)
-
-option(LLVM_INSTALL_BINUTILS_SYMLINKS
-  "Install symlinks from the binutils tool names to the corresponding LLVM tools." OFF)
-
-option(LLVM_INSTALL_CCTOOLS_SYMLINKS
-  "Install symlinks from the cctools tool names to the corresponding LLVM tools." OFF)
-
-option(LLVM_INSTALL_UTILS "Include utility binaries in the 'install' target." OFF)
-
-option(LLVM_INSTALL_TOOLCHAIN_ONLY "Only include toolchain files in the 'install' target." OFF)
-
-# Unfortunatly Clang is too eager to search directories for module maps, which can cause the
-# installed version of the maps to be found when building LLVM from source. Therefore we turn off
-# the installation by default. See llvm.org/PR31905.
-option(LLVM_INSTALL_MODULEMAPS "Install the modulemap files in the 'install' target." OFF)
-
-option(LLVM_USE_FOLDERS "Enable solution folders in Visual Studio. Disable for Express versions." ON)
-if ( LLVM_USE_FOLDERS )
-  set_property(GLOBAL PROPERTY USE_FOLDERS ON)
-endif()
-
-include(VersionFromVCS)
-
-option(LLVM_APPEND_VC_REV
-  "Embed the version control system revision in LLVM" ON)
-
-set(PACKAGE_NAME LLVM)
-set(PACKAGE_STRING "${PACKAGE_NAME} ${PACKAGE_VERSION}")
-set(PACKAGE_BUGREPORT "https://bugs.llvm.org/")
-
-set(BUG_REPORT_URL "${PACKAGE_BUGREPORT}" CACHE STRING
-  "Default URL where bug reports are to be submitted.")
-
-# Configure CPack.
-set(CPACK_PACKAGE_INSTALL_DIRECTORY "LLVM")
-set(CPACK_PACKAGE_VENDOR "LLVM")
-set(CPACK_PACKAGE_VERSION_MAJOR ${LLVM_VERSION_MAJOR})
-set(CPACK_PACKAGE_VERSION_MINOR ${LLVM_VERSION_MINOR})
-set(CPACK_PACKAGE_VERSION_PATCH ${LLVM_VERSION_PATCH})
-set(CPACK_PACKAGE_VERSION ${PACKAGE_VERSION})
-set(CPACK_RESOURCE_FILE_LICENSE "${CMAKE_CURRENT_SOURCE_DIR}/LICENSE.TXT")
-set(CPACK_NSIS_COMPRESSOR "/SOLID lzma \r\n SetCompressorDictSize 32")
-if(WIN32 AND NOT UNIX)
-  set(CPACK_PACKAGE_INSTALL_REGISTRY_KEY "LLVM")
-  set(CPACK_PACKAGE_ICON "${CMAKE_CURRENT_SOURCE_DIR}\\\\cmake\\\\nsis_logo.bmp")
-  set(CPACK_NSIS_MUI_ICON "${CMAKE_CURRENT_SOURCE_DIR}\\\\cmake\\\\nsis_icon.ico")
-  set(CPACK_NSIS_MUI_UNIICON "${CMAKE_CURRENT_SOURCE_DIR}\\\\cmake\\\\nsis_icon.ico")
-  set(CPACK_NSIS_MODIFY_PATH "ON")
-  set(CPACK_NSIS_ENABLE_UNINSTALL_BEFORE_INSTALL "ON")
-  if( CMAKE_CL_64 )
-    set(CPACK_NSIS_INSTALL_ROOT "$PROGRAMFILES64")
-  endif()
-endif()
-include(CPack)
-
-# Sanity check our source directory to make sure that we are not trying to
-# generate an in-source build (unless on MSVC_IDE, where it is ok), and to make
-# sure that we don't have any stray generated files lying around in the tree
-# (which would end up getting picked up by header search, instead of the correct
-# versions).
-if( CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_CURRENT_BINARY_DIR AND NOT MSVC_IDE )
-  message(FATAL_ERROR "In-source builds are not allowed.
-Please create a directory and run cmake from there, passing the path
-to this source directory as the last argument.
-This process created the file `CMakeCache.txt' and the directory `CMakeFiles'.
-Please delete them.")
-endif()
-
-string(TOUPPER "${CMAKE_BUILD_TYPE}" uppercase_CMAKE_BUILD_TYPE)
-
-if (CMAKE_BUILD_TYPE AND
-    NOT uppercase_CMAKE_BUILD_TYPE MATCHES "^(DEBUG|RELEASE|RELWITHDEBINFO|MINSIZEREL)$")
-  message(FATAL_ERROR "Invalid value for CMAKE_BUILD_TYPE: ${CMAKE_BUILD_TYPE}")
-endif()
-
-set(LLVM_LIBDIR_SUFFIX "" CACHE STRING "Define suffix of library directory name (32/64)" )
-
-set(LLVM_TOOLS_INSTALL_DIR "bin" CACHE STRING "Path for binary subdirectory (defaults to 'bin')")
-mark_as_advanced(LLVM_TOOLS_INSTALL_DIR)
-
-set(LLVM_UTILS_INSTALL_DIR "${LLVM_TOOLS_INSTALL_DIR}" CACHE STRING
-    "Path to install LLVM utilities (enabled by LLVM_INSTALL_UTILS=ON) (defaults to LLVM_TOOLS_INSTALL_DIR)")
-mark_as_advanced(LLVM_UTILS_INSTALL_DIR)
-
-# They are used as destination of target generators.
-set(LLVM_RUNTIME_OUTPUT_INTDIR ${CMAKE_CURRENT_BINARY_DIR}/${CMAKE_CFG_INTDIR}/bin)
-set(LLVM_LIBRARY_OUTPUT_INTDIR ${CMAKE_CURRENT_BINARY_DIR}/${CMAKE_CFG_INTDIR}/lib${LLVM_LIBDIR_SUFFIX})
-if(WIN32 OR CYGWIN)
-  # DLL platform -- put DLLs into bin.
-  set(LLVM_SHLIB_OUTPUT_INTDIR ${LLVM_RUNTIME_OUTPUT_INTDIR})
-else()
-  set(LLVM_SHLIB_OUTPUT_INTDIR ${LLVM_LIBRARY_OUTPUT_INTDIR})
-endif()
-
-# Each of them corresponds to llvm-config's.
-set(LLVM_TOOLS_BINARY_DIR ${LLVM_RUNTIME_OUTPUT_INTDIR}) # --bindir
-set(LLVM_LIBRARY_DIR      ${LLVM_LIBRARY_OUTPUT_INTDIR}) # --libdir
-set(LLVM_MAIN_SRC_DIR     ${CMAKE_CURRENT_SOURCE_DIR}  ) # --src-root
-set(LLVM_MAIN_INCLUDE_DIR ${LLVM_MAIN_SRC_DIR}/include ) # --includedir
-set(LLVM_BINARY_DIR       ${CMAKE_CURRENT_BINARY_DIR}  ) # --prefix
-
-# Note: LLVM_CMAKE_DIR does not include generated files
-set(LLVM_CMAKE_DIR ${LLVM_MAIN_SRC_DIR}/cmake/modules)
-set(LLVM_EXAMPLES_BINARY_DIR ${LLVM_BINARY_DIR}/examples)
-set(LLVM_INCLUDE_DIR ${CMAKE_CURRENT_BINARY_DIR}/include)
-
-# List of all targets to be built by default:
-set(LLVM_ALL_TARGETS
-  AArch64
-  AMDGPU
-  ARM
-  AVR
-  BPF
-  Hexagon
-  Lanai
-  Mips
-  MSP430
-  NVPTX
-  PowerPC
-  RISCV
-  Sparc
-  SystemZ
-  WebAssembly
-  X86
-  XCore
-  )
-
-# List of targets with JIT support:
-set(LLVM_TARGETS_WITH_JIT X86 PowerPC AArch64 ARM Mips SystemZ)
-
-set(LLVM_TARGETS_TO_BUILD "all"
-    CACHE STRING "Semicolon-separated list of targets to build, or \"all\".")
-
-set(LLVM_EXPERIMENTAL_TARGETS_TO_BUILD ""
-  CACHE STRING "Semicolon-separated list of experimental targets to build.")
-
-option(BUILD_SHARED_LIBS
-  "Build all libraries as shared libraries instead of static" OFF)
-
-option(LLVM_ENABLE_BACKTRACES "Enable embedding backtraces on crash." ON)
-if(LLVM_ENABLE_BACKTRACES)
-  set(ENABLE_BACKTRACES 1)
-endif()
-
-option(LLVM_ENABLE_UNWIND_TABLES "Emit unwind tables for the libraries" ON)
-
-option(LLVM_ENABLE_CRASH_OVERRIDES "Enable crash overrides." ON)
-if(LLVM_ENABLE_CRASH_OVERRIDES)
-  set(ENABLE_CRASH_OVERRIDES 1)
-endif()
-
-option(LLVM_ENABLE_CRASH_DUMPS "Turn on memory dumps on crashes. Currently only implemented on Windows." OFF)
-
-option(LLVM_ENABLE_FFI "Use libffi to call external functions from the interpreter" OFF)
-set(FFI_LIBRARY_DIR "" CACHE PATH "Additional directory, where CMake should search for libffi.so")
-set(FFI_INCLUDE_DIR "" CACHE PATH "Additional directory, where CMake should search for ffi.h or ffi/ffi.h")
-
-set(LLVM_TARGET_ARCH "host"
-  CACHE STRING "Set target to use for LLVM JIT or use \"host\" for automatic detection.")
-
-option(LLVM_ENABLE_TERMINFO "Use terminfo database if available." ON)
-
-set(LLVM_ENABLE_LIBXML2 "ON" CACHE STRING "Use libxml2 if available. Can be ON, OFF, or FORCE_ON")
-
-option(LLVM_ENABLE_LIBEDIT "Use libedit if available." ON)
-
-option(LLVM_ENABLE_LIBPFM "Use libpfm for performance counters if available." ON)
-
-# On z/OS, threads cannot be used because TLS is not supported.
-if (CMAKE_SYSTEM_NAME MATCHES "OS390")
-  option(LLVM_ENABLE_THREADS "Use threads if available." OFF)
-else()
-  option(LLVM_ENABLE_THREADS "Use threads if available." ON)
-endif()
-
-set(LLVM_ENABLE_ZLIB "ON" CACHE STRING "Use zlib for compression/decompression if available. Can be ON, OFF, or FORCE_ON")
-
-set(LLVM_Z3_INSTALL_DIR "" CACHE STRING "Install directory of the Z3 solver.")
-
-option(LLVM_ENABLE_Z3_SOLVER
-  "Enable Support for the Z3 constraint solver in LLVM."
-  ${LLVM_ENABLE_Z3_SOLVER_DEFAULT}
-)
-
-if (LLVM_ENABLE_Z3_SOLVER)
-  find_package(Z3 4.7.1)
-
-  if (LLVM_Z3_INSTALL_DIR)
-    if (NOT Z3_FOUND)
-      message(FATAL_ERROR "Z3 >= 4.7.1 has not been found in LLVM_Z3_INSTALL_DIR: ${LLVM_Z3_INSTALL_DIR}.")
-    endif()
-  endif()
-
-  if (NOT Z3_FOUND)
-    message(FATAL_ERROR "LLVM_ENABLE_Z3_SOLVER cannot be enabled when Z3 is not available.")
-  endif()
-
-  set(LLVM_WITH_Z3 1)
-endif()
-
-set(LLVM_ENABLE_Z3_SOLVER_DEFAULT "${Z3_FOUND}")
-
-
-if( LLVM_TARGETS_TO_BUILD STREQUAL "all" )
-  set( LLVM_TARGETS_TO_BUILD ${LLVM_ALL_TARGETS} )
-endif()
-
-set(LLVM_TARGETS_TO_BUILD
-   ${LLVM_TARGETS_TO_BUILD}
-   ${LLVM_EXPERIMENTAL_TARGETS_TO_BUILD})
-list(REMOVE_DUPLICATES LLVM_TARGETS_TO_BUILD)
-
-option(LLVM_ENABLE_PIC "Build Position-Independent Code" ON)
-option(LLVM_ENABLE_MODULES "Compile with C++ modules enabled." OFF)
-if(${CMAKE_SYSTEM_NAME} MATCHES "Darwin")
-  option(LLVM_ENABLE_MODULE_DEBUGGING "Compile with -gmodules." ON)
-else()
-  option(LLVM_ENABLE_MODULE_DEBUGGING "Compile with -gmodules." OFF)
-endif()
-option(LLVM_ENABLE_LOCAL_SUBMODULE_VISIBILITY "Compile with -fmodules-local-submodule-visibility." ON)
-option(LLVM_ENABLE_LIBCXX "Use libc++ if available." OFF)
-option(LLVM_STATIC_LINK_CXX_STDLIB "Statically link the standard library." OFF)
-option(LLVM_ENABLE_LLD "Use lld as C and C++ linker." OFF)
-option(LLVM_ENABLE_PEDANTIC "Compile with pedantic enabled." ON)
-option(LLVM_ENABLE_WERROR "Fail and stop if a warning is triggered." OFF)
-
-option(LLVM_ENABLE_DUMP "Enable dump functions even when assertions are disabled" OFF)
-
-if( NOT uppercase_CMAKE_BUILD_TYPE STREQUAL "DEBUG" )
-  option(LLVM_ENABLE_ASSERTIONS "Enable assertions" OFF)
-else()
-  option(LLVM_ENABLE_ASSERTIONS "Enable assertions" ON)
-endif()
-
-option(LLVM_ENABLE_EXPENSIVE_CHECKS "Enable expensive checks" OFF)
-
-# While adding scalable vector support to LLVM, we temporarily want to
-# allow an implicit conversion of TypeSize to uint64_t, and to allow
-# code to get the fixed number of elements from a possibly scalable vector.
-# This CMake flag enables a more strict mode where it asserts that the type
-# is not a scalable vector type.
-#
-# Enabling this flag makes it easier to find cases where the compiler makes
-# assumptions on the size being 'fixed size', when building tests for
-# SVE/SVE2 or other scalable vector architectures.
-option(LLVM_ENABLE_STRICT_FIXED_SIZE_VECTORS
-       "Enable assertions that type is not scalable in implicit conversion from TypeSize to uint64_t and calls to getNumElements" OFF)
-
-set(LLVM_ABI_BREAKING_CHECKS "WITH_ASSERTS" CACHE STRING
-  "Enable abi-breaking checks.  Can be WITH_ASSERTS, FORCE_ON or FORCE_OFF.")
-
-option(LLVM_FORCE_USE_OLD_TOOLCHAIN
-       "Set to ON to force using an old, unsupported host toolchain." OFF)
-
-set(LLVM_LOCAL_RPATH "" CACHE FILEPATH
-  "If set, an absolute path added as rpath on binaries that do not already contain an executable-relative rpath.")
-
-option(LLVM_TEMPORARILY_ALLOW_OLD_TOOLCHAIN
-       "Set to ON to only warn when using a toolchain which is about to be deprecated, instead of emitting an error." OFF)
-
-option(LLVM_USE_INTEL_JITEVENTS
-  "Use Intel JIT API to inform Intel(R) VTune(TM) Amplifier XE 2011 about JIT code"
-  OFF)
-
-if( LLVM_USE_INTEL_JITEVENTS )
-  # Verify we are on a supported platform
-  if( NOT CMAKE_SYSTEM_NAME MATCHES "Windows" AND NOT CMAKE_SYSTEM_NAME MATCHES "Linux" )
-    message(FATAL_ERROR
-      "Intel JIT API support is available on Linux and Windows only.")
-  endif()
-endif( LLVM_USE_INTEL_JITEVENTS )
-
-option(LLVM_USE_OPROFILE
-  "Use opagent JIT interface to inform OProfile about JIT code" OFF)
-
-option(LLVM_EXTERNALIZE_DEBUGINFO
-  "Generate dSYM files and strip executables and libraries (Darwin Only)" OFF)
-
-set(LLVM_CODESIGNING_IDENTITY "" CACHE STRING
-  "Sign executables and dylibs with the given identity or skip if empty (Darwin Only)")
-
-# If enabled, verify we are on a platform that supports oprofile.
-if( LLVM_USE_OPROFILE )
-  if( NOT CMAKE_SYSTEM_NAME MATCHES "Linux" )
-    message(FATAL_ERROR "OProfile support is available on Linux only.")
-  endif( NOT CMAKE_SYSTEM_NAME MATCHES "Linux" )
-endif( LLVM_USE_OPROFILE )
-
-option(LLVM_USE_PERF
-  "Use perf JIT interface to inform perf about JIT code" OFF)
-
-# If enabled, verify we are on a platform that supports perf.
-if( LLVM_USE_PERF )
-  if( NOT CMAKE_SYSTEM_NAME MATCHES "Linux" )
-    message(FATAL_ERROR "perf support is available on Linux only.")
-  endif( NOT CMAKE_SYSTEM_NAME MATCHES "Linux" )
-endif( LLVM_USE_PERF )
-
-set(LLVM_USE_SANITIZER "" CACHE STRING
-  "Define the sanitizer used to build binaries and tests.")
-option(LLVM_OPTIMIZE_SANITIZED_BUILDS "Pass -O1 on debug sanitizer builds" ON)
-set(LLVM_UBSAN_FLAGS
-    "-fsanitize=undefined -fno-sanitize=vptr,function -fno-sanitize-recover=all"
-    CACHE STRING
-    "Compile flags set to enable UBSan. Only used if LLVM_USE_SANITIZER contains 'Undefined'.")
-set(LLVM_LIB_FUZZING_ENGINE "" CACHE PATH
-  "Path to fuzzing library for linking with fuzz targets")
-
-option(LLVM_USE_SPLIT_DWARF
-  "Use -gsplit-dwarf when compiling llvm and --gdb-index when linking." OFF)
-
-# Define an option controlling whether we should build for 32-bit on 64-bit
-# platforms, where supported.
-if( CMAKE_SIZEOF_VOID_P EQUAL 8 AND NOT (WIN32 OR ${CMAKE_SYSTEM_NAME} MATCHES "AIX"))
-  # TODO: support other platforms and toolchains.
-  option(LLVM_BUILD_32_BITS "Build 32 bits executables and libraries." OFF)
-endif()
-
-# Define the default arguments to use with 'lit', and an option for the user to
-# override.
-set(LIT_ARGS_DEFAULT "-sv")
-if (MSVC_IDE OR XCODE)
-  set(LIT_ARGS_DEFAULT "${LIT_ARGS_DEFAULT} --no-progress-bar")
-endif()
-set(LLVM_LIT_ARGS "${LIT_ARGS_DEFAULT}" CACHE STRING "Default options for lit")
-
-# On Win32 hosts, provide an option to specify the path to the GnuWin32 tools.
-if( WIN32 AND NOT CYGWIN )
-  set(LLVM_LIT_TOOLS_DIR "" CACHE PATH "Path to GnuWin32 tools")
-endif()
-
-set(LLVM_INTEGRATED_CRT_ALLOC "" CACHE PATH "Replace the Windows CRT allocator with any of {rpmalloc|mimalloc|snmalloc}. Only works with /MT enabled.")
-if(LLVM_INTEGRATED_CRT_ALLOC)
-  if(NOT WIN32)
-    message(FATAL_ERROR "LLVM_INTEGRATED_CRT_ALLOC is only supported on Windows.")
-  endif()
-  if(LLVM_USE_SANITIZER)
-    message(FATAL_ERROR "LLVM_INTEGRATED_CRT_ALLOC cannot be used along with LLVM_USE_SANITIZER!")
-  endif()
-  if(CMAKE_BUILD_TYPE AND uppercase_CMAKE_BUILD_TYPE STREQUAL "DEBUG")
-    message(FATAL_ERROR "The Debug target isn't supported along with LLVM_INTEGRATED_CRT_ALLOC!")
-  endif()
-endif()
-
-# Define options to control the inclusion and default build behavior for
-# components which may not strictly be necessary (tools, examples, and tests).
-#
-# This is primarily to support building smaller or faster project files.
-option(LLVM_INCLUDE_TOOLS "Generate build targets for the LLVM tools." ON)
-option(LLVM_BUILD_TOOLS
-  "Build the LLVM tools. If OFF, just generate build targets." ON)
-
-option(LLVM_INCLUDE_UTILS "Generate build targets for the LLVM utils." ON)
-option(LLVM_BUILD_UTILS
-  "Build LLVM utility binaries. If OFF, just generate build targets." ON)
-
-option(LLVM_INCLUDE_RUNTIMES "Generate build targets for the LLVM runtimes." ON)
-option(LLVM_BUILD_RUNTIMES
-  "Build the LLVM runtimes. If OFF, just generate build targets." ON)
-
-option(LLVM_BUILD_RUNTIME
-  "Build the LLVM runtime libraries." ON)
-option(LLVM_BUILD_EXAMPLES
-  "Build the LLVM example programs. If OFF, just generate build targets." OFF)
-option(LLVM_INCLUDE_EXAMPLES "Generate build targets for the LLVM examples" ON)
-
-if(LLVM_BUILD_EXAMPLES)
-  add_definitions(-DBUILD_EXAMPLES)
-endif(LLVM_BUILD_EXAMPLES)
-
-option(LLVM_BUILD_TESTS
-  "Build LLVM unit tests. If OFF, just generate build targets." OFF)
-option(LLVM_INCLUDE_TESTS "Generate build targets for the LLVM unit tests." ON)
-option(LLVM_INCLUDE_GO_TESTS "Include the Go bindings tests in test build targets." ON)
-
-option(LLVM_BUILD_BENCHMARKS "Add LLVM benchmark targets to the list of default
-targets. If OFF, benchmarks still could be built using Benchmarks target." OFF)
-option(LLVM_INCLUDE_BENCHMARKS "Generate benchmark targets. If OFF, benchmarks can't be built." ON)
-
-option (LLVM_BUILD_DOCS "Build the llvm documentation." OFF)
-option (LLVM_INCLUDE_DOCS "Generate build targets for llvm documentation." ON)
-option (LLVM_ENABLE_DOXYGEN "Use doxygen to generate llvm API documentation." OFF)
-option (LLVM_ENABLE_SPHINX "Use Sphinx to generate llvm documentation." OFF)
-option (LLVM_ENABLE_OCAMLDOC "Build OCaml bindings documentation." ON)
-option (LLVM_ENABLE_BINDINGS "Build bindings." ON)
-
-set(LLVM_INSTALL_DOXYGEN_HTML_DIR "share/doc/llvm/doxygen-html"
-    CACHE STRING "Doxygen-generated HTML documentation install directory")
-set(LLVM_INSTALL_OCAMLDOC_HTML_DIR "share/doc/llvm/ocaml-html"
-    CACHE STRING "OCamldoc-generated HTML documentation install directory")
-
-option (LLVM_BUILD_EXTERNAL_COMPILER_RT
-  "Build compiler-rt as an external project." OFF)
-
-option (LLVM_VERSION_PRINTER_SHOW_HOST_TARGET_INFO
-  "Show target and host info when tools are invoked with --version." ON)
-
-# You can configure which libraries from LLVM you want to include in the
-# shared library by setting LLVM_DYLIB_COMPONENTS to a semi-colon delimited
-# list of LLVM components. All component names handled by llvm-config are valid.
-if(NOT DEFINED LLVM_DYLIB_COMPONENTS)
-  set(LLVM_DYLIB_COMPONENTS "all" CACHE STRING
-    "Semicolon-separated list of components to include in libLLVM, or \"all\".")
-endif()
-
-if(MSVC)
-  option(LLVM_BUILD_LLVM_C_DYLIB "Build LLVM-C.dll (Windows only)" ON)
-  # Set this variable to OFF here so it can't be set with a command-line
-  # argument.
-  set (LLVM_LINK_LLVM_DYLIB OFF)
-  if (BUILD_SHARED_LIBS)
-    message(FATAL_ERROR "BUILD_SHARED_LIBS options is not supported on Windows.")
-  endif()
-else()
-  option(LLVM_LINK_LLVM_DYLIB "Link tools against the libllvm dynamic library" OFF)
-  option(LLVM_BUILD_LLVM_C_DYLIB "Build libllvm-c re-export library (Darwin only)" OFF)
-  set(LLVM_BUILD_LLVM_DYLIB_default OFF)
-  if(LLVM_LINK_LLVM_DYLIB OR LLVM_BUILD_LLVM_C_DYLIB)
-    set(LLVM_BUILD_LLVM_DYLIB_default ON)
-  endif()
-  option(LLVM_BUILD_LLVM_DYLIB "Build libllvm dynamic library" ${LLVM_BUILD_LLVM_DYLIB_default})
-endif()
-
-if (LLVM_LINK_LLVM_DYLIB AND BUILD_SHARED_LIBS)
-  message(FATAL_ERROR "Cannot enable BUILD_SHARED_LIBS with LLVM_LINK_LLVM_DYLIB.  We recommend disabling BUILD_SHARED_LIBS.")
-endif()
-
-option(LLVM_OPTIMIZED_TABLEGEN "Force TableGen to be built with optimization" OFF)
-if(CMAKE_CROSSCOMPILING OR (LLVM_OPTIMIZED_TABLEGEN AND (LLVM_ENABLE_ASSERTIONS OR CMAKE_CONFIGURATION_TYPES)))
-  set(LLVM_USE_HOST_TOOLS ON)
-endif()
-
-if (MSVC_IDE)
-  option(LLVM_ADD_NATIVE_VISUALIZERS_TO_SOLUTION "Configure project to use Visual Studio native visualizers" TRUE)
-endif()
-
-if (LLVM_BUILD_INSTRUMENTED OR LLVM_BUILD_INSTRUMENTED_COVERAGE OR
-    LLVM_ENABLE_IR_PGO)
-  if(NOT LLVM_PROFILE_MERGE_POOL_SIZE)
-    # A pool size of 1-2 is probably sufficient on a SSD. 3-4 should be fine
-    # for spining disks. Anything higher may only help on slower mediums.
-    set(LLVM_PROFILE_MERGE_POOL_SIZE "4")
-  endif()
-  if(NOT LLVM_PROFILE_FILE_PATTERN)
-    if(NOT LLVM_PROFILE_DATA_DIR)
-      file(TO_NATIVE_PATH "${LLVM_BINARY_DIR}/profiles" LLVM_PROFILE_DATA_DIR)
-    endif()
-    file(TO_NATIVE_PATH "${LLVM_PROFILE_DATA_DIR}/%${LLVM_PROFILE_MERGE_POOL_SIZE}m.profraw" LLVM_PROFILE_FILE_PATTERN)
-  endif()
-  if(NOT LLVM_CSPROFILE_FILE_PATTERN)
-    if(NOT LLVM_CSPROFILE_DATA_DIR)
-      file(TO_NATIVE_PATH "${LLVM_BINARY_DIR}/csprofiles" LLVM_CSPROFILE_DATA_DIR)
-    endif()
-    file(TO_NATIVE_PATH "${LLVM_CSPROFILE_DATA_DIR}/%${LLVM_PROFILE_MERGE_POOL_SIZE}m.profraw" LLVM_CSPROFILE_FILE_PATTERN)
-  endif()
-endif()
-
-if (LLVM_BUILD_STATIC)
-  set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -static")
-  # Remove shared library suffixes from use in find_library
-  foreach (shared_lib_suffix ${CMAKE_SHARED_LIBRARY_SUFFIX} ${CMAKE_IMPORT_LIBRARY_SUFFIX})
-    list(FIND CMAKE_FIND_LIBRARY_SUFFIXES ${shared_lib_suffix} shared_lib_suffix_idx)
-    if(NOT ${shared_lib_suffix_idx} EQUAL -1)
-      list(REMOVE_AT CMAKE_FIND_LIBRARY_SUFFIXES ${shared_lib_suffix_idx})
-    endif()
-  endforeach()
-endif()
-
-# Use libtool instead of ar if you are both on an Apple host, and targeting Apple.
-if(CMAKE_HOST_APPLE AND APPLE)
-  include(UseLibtool)
-endif()
-
-# Override the default target with an environment variable named by LLVM_TARGET_TRIPLE_ENV.
-set(LLVM_TARGET_TRIPLE_ENV CACHE STRING "The name of environment variable to override default target. Disabled by blank.")
-mark_as_advanced(LLVM_TARGET_TRIPLE_ENV)
-
-if(CMAKE_SYSTEM_NAME MATCHES "Linux")
-  set(LLVM_ENABLE_PER_TARGET_RUNTIME_DIR_default ON)
-else()
-  set(LLVM_ENABLE_PER_TARGET_RUNTIME_DIR_default OFF)
-endif()
-set(LLVM_ENABLE_PER_TARGET_RUNTIME_DIR ${LLVM_ENABLE_PER_TARGET_RUNTIME_DIR_default} CACHE BOOL
-  "Enable per-target runtimes directory")
-
-set(LLVM_PROFDATA_FILE "" CACHE FILEPATH
-  "Profiling data file to use when compiling in order to improve runtime performance.")
-
-# All options referred to from HandleLLVMOptions have to be specified
-# BEFORE this include, otherwise options will not be correctly set on
-# first cmake run
-include(config-ix)
-
-# By default, we target the host, but this can be overridden at CMake
-# invocation time.
-set(LLVM_DEFAULT_TARGET_TRIPLE "${LLVM_HOST_TRIPLE}" CACHE STRING
-  "Default target for which LLVM will generate code." )
-set(TARGET_TRIPLE "${LLVM_DEFAULT_TARGET_TRIPLE}")
-message(STATUS "LLVM host triple: ${LLVM_HOST_TRIPLE}")
-message(STATUS "LLVM default target triple: ${LLVM_DEFAULT_TARGET_TRIPLE}")
-
-if(WIN32 OR CYGWIN)
-  if(BUILD_SHARED_LIBS OR LLVM_BUILD_LLVM_DYLIB)
-    set(LLVM_ENABLE_PLUGINS_default ON)
-  else()
-    set(LLVM_ENABLE_PLUGINS_default OFF)
-  endif()
-else()
-  set(LLVM_ENABLE_PLUGINS_default ${LLVM_ENABLE_PIC})
-endif()
-option(LLVM_ENABLE_PLUGINS "Enable plugin support" ${LLVM_ENABLE_PLUGINS_default})
-
-set(LLVM_ENABLE_NEW_PASS_MANAGER TRUE CACHE BOOL
-  "Enable the new pass manager by default.")
-if(NOT LLVM_ENABLE_NEW_PASS_MANAGER)
-  message(WARNING "Using the legacy pass manager for the optimization pipeline"
-                  " is deprecated. The functionality will degrade over time and"
-                  " be removed in a future release.")
-endif()
-
-include(HandleLLVMOptions)
-
-find_package(Python3 ${LLVM_MINIMUM_PYTHON_VERSION} REQUIRED
-    COMPONENTS Interpreter)
-
-######
-
-# Configure all of the various header file fragments LLVM uses which depend on
-# configuration variables.
-set(LLVM_ENUM_TARGETS "")
-set(LLVM_ENUM_ASM_PRINTERS "")
-set(LLVM_ENUM_ASM_PARSERS "")
-set(LLVM_ENUM_DISASSEMBLERS "")
-set(LLVM_ENUM_TARGETMCAS "")
-foreach(t ${LLVM_TARGETS_TO_BUILD})
-  set( td ${LLVM_MAIN_SRC_DIR}/lib/Target/${t} )
-
-  list(FIND LLVM_ALL_TARGETS ${t} idx)
-  list(FIND LLVM_EXPERIMENTAL_TARGETS_TO_BUILD ${t} idy)
-  # At this point, LLVMBUILDTOOL already checked all the targets passed in
-  # LLVM_TARGETS_TO_BUILD and LLVM_EXPERIMENTAL_TARGETS_TO_BUILD, so
-  # this test just makes sure that any experimental targets were passed via
-  # LLVM_EXPERIMENTAL_TARGETS_TO_BUILD, not LLVM_TARGETS_TO_BUILD.
-  if( idx LESS 0 AND idy LESS 0 )
-    message(FATAL_ERROR "The target `${t}' is experimental and must be passed "
-      "via LLVM_EXPERIMENTAL_TARGETS_TO_BUILD.")
-  else()
-    set(LLVM_ENUM_TARGETS "${LLVM_ENUM_TARGETS}LLVM_TARGET(${t})\n")
-  endif()
-
-  file(GLOB asmp_file "${td}/*AsmPrinter.cpp")
-  if( asmp_file )
-    set(LLVM_ENUM_ASM_PRINTERS
-      "${LLVM_ENUM_ASM_PRINTERS}LLVM_ASM_PRINTER(${t})\n")
-  endif()
-  if( EXISTS ${td}/AsmParser/CMakeLists.txt )
-    set(LLVM_ENUM_ASM_PARSERS
-      "${LLVM_ENUM_ASM_PARSERS}LLVM_ASM_PARSER(${t})\n")
-  endif()
-  if( EXISTS ${td}/Disassembler/CMakeLists.txt )
-    set(LLVM_ENUM_DISASSEMBLERS
-      "${LLVM_ENUM_DISASSEMBLERS}LLVM_DISASSEMBLER(${t})\n")
-  endif()
-    if( EXISTS ${td}/MCA/CMakeLists.txt )
-    set(LLVM_ENUM_TARGETMCAS
-      "${LLVM_ENUM_TARGETMCAS}LLVM_TARGETMCA(${t})\n")
-  endif()
-endforeach(t)
-
-# Produce the target definition files, which provide a way for clients to easily
-# include various classes of targets.
-configure_file(
-  ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/AsmPrinters.def.in
-  ${LLVM_INCLUDE_DIR}/llvm/Config/AsmPrinters.def
-  )
-configure_file(
-  ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/AsmParsers.def.in
-  ${LLVM_INCLUDE_DIR}/llvm/Config/AsmParsers.def
-  )
-configure_file(
-  ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/Disassemblers.def.in
-  ${LLVM_INCLUDE_DIR}/llvm/Config/Disassemblers.def
-  )
-configure_file(
-  ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/Targets.def.in
-  ${LLVM_INCLUDE_DIR}/llvm/Config/Targets.def
-  )
-configure_file(
-  ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/TargetMCAs.def.in
-  ${LLVM_INCLUDE_DIR}/llvm/Config/TargetMCAs.def
-  )
-
-# They are not referenced. See set_output_directory().
-set( CMAKE_RUNTIME_OUTPUT_DIRECTORY ${LLVM_BINARY_DIR}/bin )
-set( CMAKE_LIBRARY_OUTPUT_DIRECTORY ${LLVM_BINARY_DIR}/lib${LLVM_LIBDIR_SUFFIX} )
-set( CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${LLVM_BINARY_DIR}/lib${LLVM_LIBDIR_SUFFIX} )
-
-if(LLVM_INCLUDE_TESTS)
-  include(GetErrcMessages)
-  get_errc_messages(LLVM_LIT_ERRC_MESSAGES)
-endif()
-
-# For up-to-date instructions for installing the Tensorflow dependency, refer to
-# the bot setup script: https://github.com/google/ml-compiler-opt/blob/master/buildbot/buildbot_init.sh
-# In this case, the latest C API library is available for download from
-# https://www.tensorflow.org/install/lang_c.
-# We will expose the conditional compilation variable,
-# LLVM_HAVE_TF_API, through llvm-config.h, so that a user of the LLVM library may
-# also leverage the dependency.
-set(TENSORFLOW_C_LIB_PATH "" CACHE PATH "Path to TensorFlow C library install")
-if (TENSORFLOW_C_LIB_PATH)
-  find_library(tensorflow_c_api tensorflow PATHS ${TENSORFLOW_C_LIB_PATH}/lib NO_DEFAULT_PATH REQUIRED)
-  # Currently, the protobuf headers are distributed with the pip package that corresponds to the version
-  # of the C API library.
-  find_library(tensorflow_fx tensorflow_framework PATHS ${TENSORFLOW_C_LIB_PATH}/lib NO_DEFAULT_PATH REQUIRED)
-  set(LLVM_HAVE_TF_API "ON" CACHE BOOL "Full Tensorflow API available")
-  include_directories(${TENSORFLOW_C_LIB_PATH}/include)
-  if (NOT TF_PROTO_HEADERS)
-    message(STATUS "TF_PROTO_HEADERS not defined. Looking for tensorflow pip package.")
-    execute_process(COMMAND
-      ${Python3_EXECUTABLE} "-m" "pip" "show" "tensorflow"
-      OUTPUT_VARIABLE TF_PIP_OUT)
-    if ("${TF_PIP_OUT}" STREQUAL "")
-      message(FATAL ERROR "Tensorflow pip package is also required for 'development' mode (protobuf headers)")
-    endif()
-    string(REGEX MATCH "Location: ([^\n]*\n)" TF_PIP_LOC "${TF_PIP_OUT}")
-    string(REPLACE "Location: " "" TF_PIP ${TF_PIP_LOC})
-    string(STRIP ${TF_PIP} TF_PIP)
-    set(TF_PROTO_HEADERS "${TF_PIP}/tensorflow/include")
-  endif()
-  message(STATUS "Using Tensorflow headers under: ${TF_PROTO_HEADERS}")
-  include_directories(${TF_PROTO_HEADERS})
-  add_definitions("-DGOOGLE_PROTOBUF_NO_RTTI")
-  add_definitions("-D_GLIBCXX_USE_CXX11_ABI=0")
-endif()
-
-# For up-to-date instructions for installing the Tensorflow dependency, refer to
-# the bot setup script: https://github.com/google/ml-compiler-opt/blob/master/buildbot/buildbot_init.sh
-# Specifically, assuming python3 is installed:
-# python3 -m pip install --upgrade pip && python3 -m pip install --user tf_nightly==2.3.0.dev20200528
-# Then set TENSORFLOW_AOT_PATH to the package install - usually it's ~/.local/lib/python3.7/site-packages/tensorflow
-#
-set(TENSORFLOW_AOT_PATH "" CACHE PATH "Path to TensorFlow pip install dir")
-
-if (NOT TENSORFLOW_AOT_PATH STREQUAL "")
-  set(LLVM_HAVE_TF_AOT "ON" CACHE BOOL "Tensorflow AOT available")
-  set(TENSORFLOW_AOT_COMPILER
-    "${TENSORFLOW_AOT_PATH}/../../../../bin/saved_model_cli"
-    CACHE PATH "Path to the Tensorflow AOT compiler")
-  include_directories(${TENSORFLOW_AOT_PATH}/include)
-  add_subdirectory(${TENSORFLOW_AOT_PATH}/xla_aot_runtime_src
-    ${CMAKE_ARCHIVE_OUTPUT_DIRECTORY}/tf_runtime)
-  install(TARGETS tf_xla_runtime EXPORT LLVMExports
-    ARCHIVE DESTINATION lib${LLVM_LIBDIR_SUFFIX} COMPONENT tf_xla_runtime)
-  set_property(GLOBAL APPEND PROPERTY LLVM_EXPORTS tf_xla_runtime)
-endif()
-
-# Configure the three LLVM configuration header files.
-configure_file(
-  ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/config.h.cmake
-  ${LLVM_INCLUDE_DIR}/llvm/Config/config.h)
-configure_file(
-  ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/llvm-config.h.cmake
-  ${LLVM_INCLUDE_DIR}/llvm/Config/llvm-config.h)
-configure_file(
-  ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/abi-breaking.h.cmake
-  ${LLVM_INCLUDE_DIR}/llvm/Config/abi-breaking.h)
-
-# Add target for generating source rpm package.
-set(LLVM_SRPM_USER_BINARY_SPECFILE ${CMAKE_CURRENT_SOURCE_DIR}/llvm.spec.in
-    CACHE FILEPATH ".spec file to use for srpm generation")
-set(LLVM_SRPM_BINARY_SPECFILE ${CMAKE_CURRENT_BINARY_DIR}/llvm.spec)
-set(LLVM_SRPM_DIR "${CMAKE_CURRENT_BINARY_DIR}/srpm")
-
-get_source_info(${CMAKE_CURRENT_SOURCE_DIR} revision repository)
-string(LENGTH "${revision}" revision_length)
-set(LLVM_RPM_SPEC_REVISION "${revision}")
-
-configure_file(
-  ${LLVM_SRPM_USER_BINARY_SPECFILE}
-  ${LLVM_SRPM_BINARY_SPECFILE} @ONLY)
-
-add_custom_target(srpm
-  COMMAND cpack -G TGZ --config CPackSourceConfig.cmake -B ${LLVM_SRPM_DIR}/SOURCES
-  COMMAND rpmbuild -bs --define '_topdir ${LLVM_SRPM_DIR}' ${LLVM_SRPM_BINARY_SPECFILE})
-set_target_properties(srpm PROPERTIES FOLDER "Misc")
-
-if(APPLE AND DARWIN_LTO_LIBRARY)
-  set(CMAKE_EXE_LINKER_FLAGS
-    "${CMAKE_EXE_LINKER_FLAGS} -Wl,-lto_library -Wl,${DARWIN_LTO_LIBRARY}")
-  set(CMAKE_SHARED_LINKER_FLAGS
-    "${CMAKE_SHARED_LINKER_FLAGS} -Wl,-lto_library -Wl,${DARWIN_LTO_LIBRARY}")
-  set(CMAKE_MODULE_LINKER_FLAGS
-    "${CMAKE_MODULE_LINKER_FLAGS} -Wl,-lto_library -Wl,${DARWIN_LTO_LIBRARY}")
-endif()
-
-# Build with _XOPEN_SOURCE on AIX, as stray macros in _ALL_SOURCE mode tend to
-# break things. In this case we need to enable the large-file API as well.
-if (UNIX AND ${CMAKE_SYSTEM_NAME} MATCHES "AIX")
-          add_definitions("-D_XOPEN_SOURCE=700")
-          add_definitions("-D_LARGE_FILE_API")
-
-  # CMake versions less than 3.16 set default linker flags to include -brtl, as
-  # well as setting -G when building libraries, so clear them out. Note we only
-  # try to clear the form that CMake will set as part of its initial
-  # configuration, it is still possible the user may force it as part of a
-  # compound option.
-  if(CMAKE_VERSION VERSION_LESS 3.16)
-    string(REGEX REPLACE "(^|[ \t]+)-Wl,-brtl([ \t]+|$)" " " CMAKE_EXE_LINKER_FLAGS  "${CMAKE_EXE_LINKER_FLAGS}")
-    string(REGEX REPLACE "(^|[ \t]+)-Wl,-brtl([ \t]+|$)" " " CMAKE_SHARED_LINKER_FLAGS  "${CMAKE_SHARED_LINKER_FLAGS}")
-    string(REGEX REPLACE "(^|[ \t]+)-Wl,-brtl([ \t]+|$)" " " CMAKE_MODULE_LINKER_FLAGS "${CMAKE_MODULE_LINKER_FLAGS}")
-    string(REGEX REPLACE "(^|[ \t]+)(-Wl,)?-G([ \t]+|$)" " " CMAKE_SHARED_LIBRARY_CREATE_C_FLAGS
-      "${CMAKE_SHARED_LIBRARY_CREATE_C_FLAGS}")
-    string(REGEX REPLACE "(^|[ \t]+)(-Wl,)?-G([ \t]+|$)" " " CMAKE_SHARED_LIBRARY_CREATE_CXX_FLAGS
-      "${CMAKE_SHARED_LIBRARY_CREATE_CXX_FLAGS}")
-    string(REGEX REPLACE "(^|[ \t]+)(-Wl,)?-G([ \t]+|$)" " " CMAKE_SHARED_LIBRARY_CREATE_ASM_FLAGS
-      "${CMAKE_SHARED_LIBRARY_CREATE_ASM_FLAGS}")
-    string(REGEX REPLACE "(^|[ \t]+)-Wl,-G," " -Wl," CMAKE_SHARED_LIBRARY_CREATE_C_FLAGS
-      "${CMAKE_SHARED_LIBRARY_CREATE_C_FLAGS}")
-    string(REGEX REPLACE "(^|[ \t]+)-Wl,-G," " -Wl," CMAKE_SHARED_LIBRARY_CREATE_CXX_FLAGS
-      "${CMAKE_SHARED_LIBRARY_CREATE_CXX_FLAGS}")
-    string(REGEX REPLACE "(^|[ \t]+)-Wl,-G," " -Wl," CMAKE_SHARED_LIBRARY_CREATE_ASM_FLAGS
-      "${CMAKE_SHARED_LIBRARY_CREATE_ASM_FLAGS}")
-  endif()
-
-  # Modules should be built with -shared -Wl,-G, so we can use runtime linking
-  # with plugins.
-  string(APPEND CMAKE_MODULE_LINKER_FLAGS " -shared -Wl,-G")
-
-  # Also set the correct flags for building shared libraries.
-  string(APPEND CMAKE_SHARED_LINKER_FLAGS " -shared")
-endif()
-
-# Build with _XOPEN_SOURCE on z/OS.
-if (CMAKE_SYSTEM_NAME MATCHES "OS390")
-  add_definitions("-D_XOPEN_SOURCE=600")
-  add_definitions("-D_OPEN_SYS") # Needed for process information.
-  add_definitions("-D_OPEN_SYS_FILE_EXT") # Needed for EBCDIC I/O.
-endif()
-
-# Build with _FILE_OFFSET_BITS=64 on Solaris to match g++ >= 9.
-if (UNIX AND ${CMAKE_SYSTEM_NAME} MATCHES "SunOS")
-          add_definitions("-D_FILE_OFFSET_BITS=64")
-endif()
-
-set(CMAKE_INCLUDE_CURRENT_DIR ON)
-
-include_directories( ${LLVM_INCLUDE_DIR} ${LLVM_MAIN_INCLUDE_DIR})
-
-# when crosscompiling import the executable targets from a file
-if(LLVM_USE_HOST_TOOLS)
-  include(CrossCompile)
-  llvm_create_cross_target(LLVM NATIVE "" Release)
-endif(LLVM_USE_HOST_TOOLS)
-if(LLVM_TARGET_IS_CROSSCOMPILE_HOST)
-# Dummy use to avoid CMake Warning: Manually-specified variables were not used
-# (this is a variable that CrossCompile sets on recursive invocations)
-endif()
-
-if( ${CMAKE_SYSTEM_NAME} MATCHES SunOS )
-   # special hack for Solaris to handle crazy system sys/regset.h
-   include_directories("${LLVM_MAIN_INCLUDE_DIR}/llvm/Support/Solaris")
-endif( ${CMAKE_SYSTEM_NAME} MATCHES SunOS )
-
-# Make sure we don't get -rdynamic in every binary. For those that need it,
-# use export_executable_symbols(target).
-set(CMAKE_SHARED_LIBRARY_LINK_CXX_FLAGS "")
-
-include(AddLLVM)
-include(TableGen)
-
-include(LLVMDistributionSupport)
-
-if( MINGW AND NOT "${CMAKE_CXX_COMPILER_ID}" MATCHES "Clang" )
-  # People report that -O3 is unreliable on MinGW. The traditional
-  # build also uses -O2 for that reason:
-  llvm_replace_compiler_option(CMAKE_CXX_FLAGS_RELEASE "-O3" "-O2")
-endif()
-
-# Put this before tblgen. Else we have a circular dependence.
-add_subdirectory(lib/Demangle)
-add_subdirectory(lib/Support)
-add_subdirectory(lib/TableGen)
-
-add_subdirectory(utils/TableGen)
-
-add_subdirectory(include/llvm)
-
-add_subdirectory(lib)
-
-if( LLVM_INCLUDE_UTILS )
-  add_subdirectory(utils/FileCheck)
-  add_subdirectory(utils/PerfectShuffle)
-  add_subdirectory(utils/count)
-  add_subdirectory(utils/not)
-  add_subdirectory(utils/yaml-bench)
-else()
-  if ( LLVM_INCLUDE_TESTS )
-    message(FATAL_ERROR "Including tests when not building utils will not work.
-    Either set LLVM_INCLUDE_UTILS to On, or set LLVM_INCLUDE_TESTS to Off.")
-  endif()
-endif()
-
-# Use LLVM_ADD_NATIVE_VISUALIZERS_TO_SOLUTION instead of LLVM_INCLUDE_UTILS because it is not really a util
-if (LLVM_ADD_NATIVE_VISUALIZERS_TO_SOLUTION)
-  add_subdirectory(utils/LLVMVisualizers)
-endif()
-
-foreach( binding ${LLVM_BINDINGS_LIST} )
-  if( EXISTS "${LLVM_MAIN_SRC_DIR}/bindings/${binding}/CMakeLists.txt" )
-    add_subdirectory(bindings/${binding})
-  endif()
-endforeach()
-
-add_subdirectory(projects)
-
-if( LLVM_INCLUDE_TOOLS )
-  add_subdirectory(tools)
-endif()
-
-if( LLVM_INCLUDE_RUNTIMES )
-  add_subdirectory(runtimes)
-endif()
-
-if( LLVM_INCLUDE_EXAMPLES )
-  add_subdirectory(examples)
-endif()
-
-if( LLVM_INCLUDE_TESTS )
-  if(EXISTS ${LLVM_MAIN_SRC_DIR}/projects/test-suite AND TARGET clang)
-    include(LLVMExternalProjectUtils)
-    llvm_ExternalProject_Add(test-suite ${LLVM_MAIN_SRC_DIR}/projects/test-suite
-      USE_TOOLCHAIN
-      EXCLUDE_FROM_ALL
-      NO_INSTALL
-      ALWAYS_CLEAN)
-  endif()
-  add_subdirectory(utils/lit)
-  add_subdirectory(test)
-  add_subdirectory(unittests)
-  if( LLVM_INCLUDE_UTILS )
-    add_subdirectory(utils/unittest)
-  endif()
-
-  if (WIN32)
-    # This utility is used to prevent crashing tests from calling Dr. Watson on
-    # Windows.
-    add_subdirectory(utils/KillTheDoctor)
-  endif()
-
-  # Add a global check rule now that all subdirectories have been traversed
-  # and we know the total set of lit testsuites.
-  get_property(LLVM_LIT_TESTSUITES GLOBAL PROPERTY LLVM_LIT_TESTSUITES)
-  get_property(LLVM_LIT_PARAMS GLOBAL PROPERTY LLVM_LIT_PARAMS)
-  get_property(LLVM_LIT_DEPENDS GLOBAL PROPERTY LLVM_LIT_DEPENDS)
-  get_property(LLVM_LIT_EXTRA_ARGS GLOBAL PROPERTY LLVM_LIT_EXTRA_ARGS)
-  get_property(LLVM_ADDITIONAL_TEST_TARGETS
-               GLOBAL PROPERTY LLVM_ADDITIONAL_TEST_TARGETS)
-  get_property(LLVM_ADDITIONAL_TEST_DEPENDS
-               GLOBAL PROPERTY LLVM_ADDITIONAL_TEST_DEPENDS)
-  add_lit_target(check-all
-    "Running all regression tests"
-    ${LLVM_LIT_TESTSUITES}
-    PARAMS ${LLVM_LIT_PARAMS}
-    DEPENDS ${LLVM_LIT_DEPENDS} ${LLVM_ADDITIONAL_TEST_TARGETS}
-    ARGS ${LLVM_LIT_EXTRA_ARGS}
-    )
-  if(TARGET check-runtimes)
-    add_dependencies(check-all check-runtimes)
-  endif()
-  add_custom_target(test-depends
-                    DEPENDS ${LLVM_LIT_DEPENDS} ${LLVM_ADDITIONAL_TEST_DEPENDS})
-  set_target_properties(test-depends PROPERTIES FOLDER "Tests")
-endif()
-
-if (LLVM_INCLUDE_DOCS)
-  add_subdirectory(docs)
-endif()
-
-add_subdirectory(cmake/modules)
-
-# Do this last so that all lit targets have already been created.
-if (LLVM_INCLUDE_UTILS)
-  add_subdirectory(utils/llvm-lit)
-endif()
-
-if (NOT LLVM_INSTALL_TOOLCHAIN_ONLY)
-  install(DIRECTORY include/llvm include/llvm-c
-    DESTINATION include
-    COMPONENT llvm-headers
-    FILES_MATCHING
-    PATTERN "*.def"
-    PATTERN "*.h"
-    PATTERN "*.td"
-    PATTERN "*.inc"
-    PATTERN "LICENSE.TXT"
-    )
-
-  install(DIRECTORY ${LLVM_INCLUDE_DIR}/llvm ${LLVM_INCLUDE_DIR}/llvm-c
-    DESTINATION include
-    COMPONENT llvm-headers
-    FILES_MATCHING
-    PATTERN "*.def"
-    PATTERN "*.h"
-    PATTERN "*.gen"
-    PATTERN "*.inc"
-    # Exclude include/llvm/CMakeFiles/intrinsics_gen.dir, matched by "*.def"
-    PATTERN "CMakeFiles" EXCLUDE
-    PATTERN "config.h" EXCLUDE
-    )
-
-  if (LLVM_INSTALL_MODULEMAPS)
-    install(DIRECTORY include/llvm include/llvm-c
-            DESTINATION include
-            COMPONENT llvm-headers
-            FILES_MATCHING
-            PATTERN "module.modulemap"
-            )
-    install(FILES include/llvm/module.install.modulemap
-            DESTINATION include/llvm
-            COMPONENT llvm-headers
-            RENAME "module.extern.modulemap"
-            )
-  endif(LLVM_INSTALL_MODULEMAPS)
-
-  # Installing the headers needs to depend on generating any public
-  # tablegen'd headers.
-  add_custom_target(llvm-headers DEPENDS intrinsics_gen omp_gen)
-  set_target_properties(llvm-headers PROPERTIES FOLDER "Misc")
-
-  if (NOT LLVM_ENABLE_IDE)
-    add_llvm_install_targets(install-llvm-headers
-                             DEPENDS llvm-headers
-                             COMPONENT llvm-headers)
-  endif()
-
-  # Custom target to install all libraries.
-  add_custom_target(llvm-libraries)
-  set_target_properties(llvm-libraries PROPERTIES FOLDER "Misc")
-
-  if (NOT LLVM_ENABLE_IDE)
-    add_llvm_install_targets(install-llvm-libraries
-                             DEPENDS llvm-libraries
-                             COMPONENT llvm-libraries)
-  endif()
-
-  get_property(LLVM_LIBS GLOBAL PROPERTY LLVM_LIBS)
-  if(LLVM_LIBS)
-    list(REMOVE_DUPLICATES LLVM_LIBS)
-    foreach(lib ${LLVM_LIBS})
-      add_dependencies(llvm-libraries ${lib})
-      if (NOT LLVM_ENABLE_IDE)
-        add_dependencies(install-llvm-libraries install-${lib})
-        add_dependencies(install-llvm-libraries-stripped install-${lib}-stripped)
-      endif()
-    endforeach()
-  endif()
-endif()
-
-# This must be at the end of the LLVM root CMakeLists file because it must run
-# after all targets are created.
-llvm_distribution_add_targets()
-process_llvm_pass_plugins(GEN_CONFIG)
-include(CoverageReport)
-
-# This allows us to deploy the Universal CRT DLLs by passing -DCMAKE_INSTALL_UCRT_LIBRARIES=ON to CMake
-if (MSVC AND CMAKE_HOST_SYSTEM_NAME STREQUAL "Windows" AND CMAKE_INSTALL_UCRT_LIBRARIES)
-  include(InstallRequiredSystemLibraries)
-endif()
-
-if (LLVM_INCLUDE_BENCHMARKS)
-  # Override benchmark defaults so that when the library itself is updated these
-  # modifications are not lost.
-  set(BENCHMARK_ENABLE_TESTING OFF CACHE BOOL "Disable benchmark testing" FORCE)
-  set(BENCHMARK_ENABLE_EXCEPTIONS OFF CACHE BOOL "Disable benchmark exceptions" FORCE)
-  set(BENCHMARK_ENABLE_INSTALL OFF CACHE BOOL "Don't install benchmark" FORCE)
-  set(BENCHMARK_DOWNLOAD_DEPENDENCIES OFF CACHE BOOL "Don't download dependencies" FORCE)
-  set(BENCHMARK_ENABLE_GTEST_TESTS OFF CACHE BOOL "Disable Google Test in benchmark" FORCE)
-  # Since LLVM requires C++11 it is safe to assume that std::regex is available.
-  set(HAVE_STD_REGEX ON CACHE BOOL "OK" FORCE)
-
-  add_subdirectory(utils/benchmark)
-  add_subdirectory(benchmarks)
-endif()
-
-if (LLVM_INCLUDE_UTILS AND LLVM_INCLUDE_TOOLS)
-  add_subdirectory(utils/llvm-locstats)
-endif()
